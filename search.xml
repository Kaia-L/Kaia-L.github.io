<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>复试计划</title>
    <url>/2020/04/20/reexamine/</url>
    <content><![CDATA[<p>害！紧张！</p>
<a id="more"></a>
<h2 id="总揽"><a href="#总揽" class="headerlink" title="总揽"></a>总揽</h2><ul>
<li>自我介绍</li>
<li>项目、奖项介绍</li>
<li>对学院、专业的了解</li>
<li>问答</li>
<li>笔试2</li>
<li>英语口语贯穿其中<h2 id="应对"><a href="#应对" class="headerlink" title="应对"></a>应对</h2></li>
<li>写好自我介绍</li>
<li>项目、奖项介绍</li>
<li>为什么想学这个专业</li>
<li>问答 刷题、数据结构、面经、计算机网络</li>
<li>上述所有内容的英语</li>
<li>科目二也要复习啊</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>视频文字</title>
    <url>/2020/04/20/weibo/</url>
    <content><![CDATA[<p>毕设</p>
<a id="more"></a>
<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>老师们好<br>我是计算机卓越班的李怡珂<br>我的学号是201613137005<br>我的毕业设计的题目是——基于SnowNPL的社交媒体情感挖掘<br>下面我来介绍一下程序的大致功能</p>
<h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><p>（做个ppt，对内容进行简洁的分点描述）<br>我程序的大致功能就是<br>通过微博主页的url链接<br>模仿我们浏览微博时候的请求<br>对微博内容进行爬取<br>生成两个json文件<br>其中一个是peopel.json是爬取的微博博主的个人信息<br>另外一个是statuses.json是爬取的该博主的所有微博信息<br>下一步就是根据生成的json文件提取出值<br>生成两个CSV文件<br>通过CSV文件表格我们就可以更清晰的看到我们提取到的信息<br>再对爬取的每条微博内容进行分词<br>统计词频生成词云<br>通过SnowNPL进行情感计算<br>看出所有微博信息的情绪倾向</p>
<h2 id="演示部分"><a href="#演示部分" class="headerlink" title="演示部分"></a>演示部分</h2><p>首先我们在微博上找到一个想用来爬虫的博主的微博主页<br>将主页的URL复制到我们的程序中来<br>在终端输入crawl person<br>开始爬虫<br>我们通过终端可以看到爬虫已经开始了<br>因为我们的爬虫也是需要遵守robots协议的<br>所以在爬虫的程序中我们设置了延时是3秒钟<br>我们现在打开json文件来看看<br>我们爬下来的信息和网站中的信息是不是一样的</p>
<p>现在终端上显示我们的爬虫已经完成了<br>我们来运行一下生成展示页面的程序<br>可以看到我们把这位博主的个人信息进行了展示<br>同时在本地 我们生成了两个csv文件<br>我们打开来看一下<br>每一条微博的发布时间、微博内容、转发数、点赞数、评论数都在这里<br>我们也在本地生成了一张词云的图片<br>通过SnowNPL对每条微博的内容进行了情感分析<br>最终得出平均值<br>并对整体的情感倾向得出了判断<br>是积极的 或者说是消极的</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这就是我的整个程序的运行展示。在这个人人都可以成为媒体平台的自媒体时代，对于文本的情感分析是有很大的存在意义的。特别是在今年的疫情爆发之后，如果我们通过对社交媒体的舆论情感倾向进行分析，就可以更精准的对用户进行情感上的引导和情绪引导。从而避免网络暴力、网络恶性事件的发生。我的展示就到这里了。谢谢各位老师的观看。</p>
]]></content>
  </entry>
  <entry>
    <title>阿里云服务器上挂载程序检测学院官网更新</title>
    <url>/2020/04/20/aliyun/</url>
    <content><![CDATA[<blockquote>
<p>因为疫情原因，20年考研消息迟迟不下来，为了第一时间get到学院官网的更新消息，我写了一个爬虫小demo挂载到阿里云服务器上，并且只要一有跟新就会给我的手机号码发短信。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>开发环境<br>电脑操作系统：macOS Catalina 10.15.3<br>语言：python3<br>阿里云服务器操作系统：Centos7</p>
</blockquote>
<h2 id="整体思路："><a href="#整体思路：" class="headerlink" title="整体思路："></a>整体思路：</h2><p>python学了一个星期，太复杂的不太会。所以没有类，就几个简单的函数。大体思路就是，用requests库请求获得美院研究生招生界面的html代码，观察网站的html代码后发现，更新的新的通知链接中会有明显的/2020/。再用beautifulsoup中的find_all函数和正则表达式对html标签进行解析，那么怎么判断网站页面是否更新了呢？之前的想法是将2020年的链接和阻塞30秒后的重新获取的链接进行对比，如果有变换就是更新了。但是这个思路在实践的时候有麻烦（后面会提到）。后面发现，用一个全局变量flag来记录目前的2020年的标签，再每次get之后计算出当前的标签数，与flag进行对比，如果有变化就说明网站有了更新。有更新即给手机发短信。</p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="twilio短信服务"><a href="#twilio短信服务" class="headerlink" title="twilio短信服务"></a>twilio短信服务</h3><p>是一家开发插件的电话跟踪服务的美国加州的科技公司，Twilio的程序支持网络开发者拨打接听电话或者发短信。使用方法是在Twilio的官网上申请账号，认证自己的手机号码后会给你两个码和一个电话号码，把这些参数写进python程序中运行手机即可收到短信。具体操作自己百度，几行代码就可以实现。要注意的是，一天最多只能收到5条短信，所以在测试的时候省着点用。在第六次测试的时候我换了没有认证的电话号码报错，换回来之后就收不到短信了，我以为是我的账号或者代码出错了，百思不得其解，这个坑让我懵逼了挺久。第二天就又好了，才知道原来是一天最多只能收到5条短信。账号申请完成之后会给你15刀的免费试用，几美分一条短信，可以用很久了。</p>
<h3 id="阿里云服务器"><a href="#阿里云服务器" class="headerlink" title="阿里云服务器"></a>阿里云服务器</h3><p>阿里云的官网上项目太多了，还都是英文缩写，小白真的很懵逼。大致步骤：注册账号，与支付宝/钉钉绑定认证——&gt;申请ECS免费一个月的服务——&gt;来到ECS控制台——&gt;通过SSH与服务器进行连接（就是在网站上就可以搞定的，windows操作系统要怎么搞不太清楚，看教程好像是下了putty）——&gt;进入服务器<br>本小白理解的服务器，就是一个24小时不停机的电脑。可以在上面跑24小时一直要运行的程序。</p>
<h2 id="上手操作"><a href="#上手操作" class="headerlink" title="上手操作"></a>上手操作</h2><h3 id="先在本地测试完成爬虫-amp-发短信的代码"><a href="#先在本地测试完成爬虫-amp-发短信的代码" class="headerlink" title="先在本地测试完成爬虫&amp;发短信的代码"></a>先在本地测试完成爬虫&amp;发短信的代码</h3><p>需要的预备知识有</p>
<ul>
<li>requests请求</li>
<li>正则表达式</li>
<li>beautifulsoup解析html文件</li>
<li>apscheduler任务调度<br>这了有个坑就是Linux的cron格式，秒、分、时…的顺序如果有错的话会有问题</li>
<li>上面提到的twilio通讯平台</li>
</ul>
<p>先上整体代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span></pre></td></tr><tr><td class="code"><pre><span class="line">import time</span></pre></td></tr><tr><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span></pre></td></tr><tr><td class="code"><pre><span class="line">import re</span></pre></td></tr><tr><td class="code"><pre><span class="line">from twilio.rest import Client</span></pre></td></tr><tr><td class="code"><pre><span class="line">from datetime import datetime,tzinfo</span></pre></td></tr><tr><td class="code"><pre><span class="line">import os</span></pre></td></tr><tr><td class="code"><pre><span class="line">from apscheduler.schedulers.blocking import BlockingScheduler</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">flag &#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">def sendMessage():</span></pre></td></tr><tr><td class="code"><pre><span class="line">#这里的几个参数分别是在twilio注册时候获得的account_sid、auth_token、还有你自己的电话号码、网站给你的电话号码</span></pre></td></tr><tr><td class="code"><pre><span class="line">    account_sid &#x3D; &quot;AC*****************************&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    auth_token &#x3D; &quot;********************************&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    my_number &#x3D; &quot;+8618*********&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    twilio_number &#x3D; &quot;+15*******&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    client &#x3D; Client(account_sid,auth_token)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    message &#x3D; client.messages.create(to&#x3D;my_number,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    from_ &#x3D; twilio_number,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    body &#x3D; &#39;Updated! The time is:%s&#39;%datetime.now())</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">def getHTMLText(url):    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    try:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        r &#x3D; requests.get(url)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        r.raise_for_status()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        r.encoding &#x3D; r.apparent_encoding</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return r.text</span></pre></td></tr><tr><td class="code"><pre><span class="line">    except:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return r.status_code</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">def findA(html):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    soup &#x3D; BeautifulSoup(html,&quot;html.parser&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    count &#x3D; 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for a in soup.find_all(href &#x3D; re.compile(&quot;&#x2F;publish&#x2F;ad&#x2F;2889&#x2F;2020&#x2F;&quot;)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        count +&#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return count</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">def compare():</span></pre></td></tr><tr><td class="code"><pre><span class="line">    url &#x3D; &quot;http:&#x2F;&#x2F;www.ad.tsinghua.edu.cn&#x2F;publish&#x2F;ad&#x2F;2889&#x2F;index.html&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    html &#x3D; getHTMLText(url)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    result &#x3D; findA(html)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    global flag</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if result &#x3D;&#x3D; flag:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return False</span></pre></td></tr><tr><td class="code"><pre><span class="line">    else:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return True</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">def judge():</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if compare():</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sendMessage()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(&#39;Updated!\tThe time is:%s&#39;%datetime.now())</span></pre></td></tr><tr><td class="code"><pre><span class="line">        global flag</span></pre></td></tr><tr><td class="code"><pre><span class="line">        flag +&#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    else:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(&#39;Not updated!\tThe time is:%s&#39;%datetime.now())</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">if __name__&#x3D;&#x3D;&#39;__main__&#39;:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    scheduler &#x3D; BlockingScheduler()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    scheduler.add_job(judge,&#39;cron&#39;,minute&#x3D;&#39;*&#x2F;1&#39;,hour&#x3D;&#39;9-12,14-17&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(&#39;Press Ctrl+&#123;0&#125; to exit&#39;.format(&#39;Break&#39; if os.name &#x3D;&#x3D;&#39;nt&#39;else &#39;C&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    try:      </span></pre></td></tr><tr><td class="code"><pre><span class="line">        scheduler.start()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    except (KeyboardInterrupt, SystemExit):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pass</span></pre></td></tr></table></figure>
<p>在本地测试结果没有问题</p>
<h3 id="在服务器上配置好python3的运行环境"><a href="#在服务器上配置好python3的运行环境" class="headerlink" title="在服务器上配置好python3的运行环境"></a>在服务器上配置好python3的运行环境</h3><p>Centos7自带的是python2的运行环境。配置python3环境的教程自己百度。给个教程链接：<a href="https://blog.csdn.net/qq_37266079/article/details/103800518" target="_blank" rel="noopener">阿里云服务器中CentOS7升级Python环境</a></p>
<h3 id="上传本地文件到阿里云服务器"><a href="#上传本地文件到阿里云服务器" class="headerlink" title="上传本地文件到阿里云服务器"></a>上传本地文件到阿里云服务器</h3><p>教程自行百度。macos通过sftp上传还是挺简单的。<br>给个教程链接<a href="https://jingyan.baidu.com/article/ae97a64672d076fbfc461d29.html" target="_blank" rel="noopener">mac电脑上传文件到阿里云服务器</a></p>
<h3 id="后台运行python程序"><a href="#后台运行python程序" class="headerlink" title="后台运行python程序"></a>后台运行python程序</h3><p>服务器启动台中输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup python -u run.py &gt;  run.log &amp;</span></pre></td></tr></table></figure>
<p>程序会一直在后台运行，并且将输出写入log文件中</p>
<h3 id="来康康我的运行效果吧："><a href="#来康康我的运行效果吧：" class="headerlink" title="来康康我的运行效果吧："></a>来康康我的运行效果吧：</h3><p>设置了时间在工作日（周一到周五，9:00-12:00 14:00-17:00）每隔一分钟检测一次官网是否更新。<br><img src="/aliyun/5421587347655_.pic_hd.jpg" alt=""><br><img src="/aliyun/41587348279_.pic_hd.jpg" alt=""></p>
<blockquote>
<p>总结：使用服务器后台运行，实时监测网站是否更新。</p>
</blockquote>
<blockquote>
<p>存疑：美院有两个网址，一个是https协议，一个是http协议，第一天测试的时候https的网址是可以用的，结果第二天404了，我以为是官网蹦了，后面又发现http的网址是可以用的。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>vocabularyD</title>
    <url>/2019/12/20/vocabularyD/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>英语</th>
<th>中文</th>
</tr>
</thead>
<tbody><tr>
<td>casualty</td>
<td>伤亡人员，受害者</td>
</tr>
<tr>
<td>cemetery</td>
<td>公墓，坟场</td>
</tr>
<tr>
<td>censorship</td>
<td>审查，审查制度</td>
</tr>
<tr>
<td>&gt;cement 水泥。用水泥封起来，即墓地</td>
<td></td>
</tr>
<tr>
<td>&gt;censorship审查 - census人口普查</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-vocabulary</tag>
      </tags>
  </entry>
  <entry>
    <title>listening1</title>
    <url>/2019/12/19/listening1/</url>
    <content><![CDATA[<p>-So me and my friends ,we love  going to the concert back <del>roads</del>home.<br>-Sure.<br>-And,Ed <del>Sheer</del> Sheeran was playing at the HollyWood <del>Bowel</del>Bowl,and there’s much traffic,and I was very uncomfortable, <del>that’s say</del>let’s say,in down there, that area.<br>-Sure, she needed way.<del>a way</del><br>-So,i will say that it was the first time ,<del>maybe</del> i had maybe soilded on my pants a bit…And i was <del>out of</del> not excited,but i didn’t <del>want to</del>wanna leave.and i kind just like ,all right ,i’m ganna put a little sweater in the bottom of me ,to kind just…<br>NO!!!<br>Ok , just so you know , i never told anyone  that.<br>Yes babe,and listen we’ve all been there.<br>Wiredly i’ve been there lot and more top even when i was getting older.<br>Really, i’ve been there a lot ,and it’s happening more as i get older.<br>I thought i have been getting over but<br>i thought i would have got over it by now,but … really .. really not!<br>I cant wait to see the heatline on this one.<br>Hello Ed Sheern.<br>Honest he will like, that’s fine, that’s good for her, she deserves it .</p>
]]></content>
  </entry>
  <entry>
    <title>vocabularyC</title>
    <url>/2019/12/18/vocabularyC/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody><tr>
<td>blunder</td>
<td>因无知犯错的，愚钝的</td>
</tr>
<tr>
<td>bench</td>
<td>长椅，工作台</td>
</tr>
<tr>
<td>benign</td>
<td>慈祥的，和蔼的，</td>
</tr>
<tr>
<td>beverage</td>
<td>（酒、水之外的）饮料</td>
</tr>
<tr>
<td>*beware</td>
<td>当心，谨防</td>
</tr>
<tr>
<td>bibliography</td>
<td>参考书目，文献</td>
</tr>
<tr>
<td>biscuit</td>
<td>饼干🍪，点心🥧</td>
</tr>
<tr>
<td>blade</td>
<td>刀刃，刀片，桨叶</td>
</tr>
<tr>
<td>blanket</td>
<td>毯子，总括的，综合的</td>
</tr>
<tr>
<td>blast</td>
<td>爆炸，强劲的气流，严厉的批评</td>
</tr>
<tr>
<td>blend</td>
<td>混合物，混合，调和</td>
</tr>
<tr>
<td>blush</td>
<td>脸红</td>
</tr>
<tr>
<td>bold</td>
<td>粗体的，显眼的，大胆的，勇敢的</td>
</tr>
<tr>
<td>bolt</td>
<td>插销，关窗，闪电，</td>
</tr>
<tr>
<td>botany</td>
<td>植物学</td>
</tr>
<tr>
<td>bosom</td>
<td>胸，胸怀，内心</td>
</tr>
<tr>
<td>*bow</td>
<td>鞠躬，弯腰</td>
</tr>
<tr>
<td>bowel</td>
<td>肠，内部，深处</td>
</tr>
<tr>
<td>brace</td>
<td>支撑，支架，大括号</td>
</tr>
<tr>
<td>*brass</td>
<td>黄铜，铜器，厚颜无耻</td>
</tr>
<tr>
<td>breach</td>
<td>违反，不履行，破裂</td>
</tr>
<tr>
<td>breed</td>
<td>产生，繁殖，生殖</td>
</tr>
<tr>
<td>bribe</td>
<td>贿赂，行贿</td>
</tr>
<tr>
<td>briefcase</td>
<td>公文包</td>
</tr>
<tr>
<td>brim</td>
<td>边缘</td>
</tr>
<tr>
<td>brittle</td>
<td>易碎的</td>
</tr>
<tr>
<td>brook</td>
<td>小溪</td>
</tr>
<tr>
<td>broom</td>
<td>扫帚🧹</td>
</tr>
<tr>
<td>brutal</td>
<td>残忍的</td>
</tr>
<tr>
<td>bucket</td>
<td>桶</td>
</tr>
<tr>
<td>buffet</td>
<td>自助餐</td>
</tr>
<tr>
<td>bull</td>
<td>公牛🐂</td>
</tr>
<tr>
<td>bullet</td>
<td>子弹，枪膛</td>
</tr>
<tr>
<td>bulletin</td>
<td>新闻公告，简报</td>
</tr>
<tr>
<td>bully</td>
<td>恃强凌弱者，威胁，恐吓</td>
</tr>
<tr>
<td>*bundle</td>
<td>一捆，一批，梗，一大笔钱，匆匆送走，额外的免费服务</td>
</tr>
<tr>
<td>burglar</td>
<td>（入室）盗贼</td>
</tr>
<tr>
<td>cab</td>
<td>出租车</td>
</tr>
<tr>
<td>*cable</td>
<td>电报，电缆，有线电视</td>
</tr>
<tr>
<td>cabin</td>
<td>小木屋</td>
</tr>
<tr>
<td>cabinet</td>
<td>内阁</td>
</tr>
<tr>
<td>cafeteria</td>
<td>自助食堂</td>
</tr>
<tr>
<td>cage</td>
<td>鸟笼</td>
</tr>
<tr>
<td>cape</td>
<td>披风</td>
</tr>
<tr>
<td>calcium</td>
<td>钙</td>
</tr>
<tr>
<td>cannon</td>
<td>加农炮</td>
</tr>
<tr>
<td>canoe</td>
<td>独木舟</td>
</tr>
<tr>
<td>canvas</td>
<td>帆布</td>
</tr>
<tr>
<td>capsule</td>
<td>胶囊💊，太空舱</td>
</tr>
<tr>
<td>cardinal</td>
<td>红衣教主，首要的，基本的</td>
</tr>
<tr>
<td>caress</td>
<td>爱抚，抚摸</td>
</tr>
<tr>
<td>captive</td>
<td>囚徒，战俘，被监禁的</td>
</tr>
<tr>
<td>*cart</td>
<td>运货马车</td>
</tr>
<tr>
<td>cargo</td>
<td>货物📦</td>
</tr>
<tr>
<td>carriage</td>
<td>四轮马车</td>
</tr>
<tr>
<td>carpet</td>
<td>地毯，申诉，责骂</td>
</tr>
<tr>
<td>carpenter</td>
<td>木匠</td>
</tr>
</tbody></table>
<p>今天记不住的格外的多</p>
<blockquote>
<p>bench长椅<br>bunch一束</p>
</blockquote>
<blockquote>
<p>blind 眼睛 瞎<br>blunt 刀 钝<br>blunder 人 蠢</p>
</blockquote>
<blockquote>
<p>bush 灌木<br>brush刷<br>blush脸红</p>
</blockquote>
<blockquote>
<p>bull 公牛 - bully 恃强凌弱者<br>cow母牛 - coward懦夫</p>
</blockquote>
<p>复习*</p>
<blockquote>
<p>beware当心，谨防 区别于aware，知道了解，aware of</p>
</blockquote>
<blockquote>
<p>bow 鞠躬，弯腰<br>bowl 碗<br>bowel 肠子</p>
</blockquote>
<blockquote>
<p>brass 黄铜，铜器，厚颜无耻 ass一样厚颜无耻。脸皮向黄铜一样厚</p>
</blockquote>
<blockquote>
<p>bundle 一捆 同bunch</p>
</blockquote>
<blockquote>
<p>cable 电缆，光纤电缆像c一样细，但是却有传输信息的能力</p>
</blockquote>
<blockquote>
<p>cart 卡尔特。马车</p>
</blockquote>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-vocabulary</tag>
      </tags>
  </entry>
  <entry>
    <title>vocabularyB</title>
    <url>/2019/12/17/vocabularB/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody><tr>
<td>apparatus</td>
<td>仪器，器械</td>
</tr>
<tr>
<td>apparent</td>
<td>显然的，明显的</td>
</tr>
<tr>
<td>approach</td>
<td>接近，方式，态度，着手处理，对付</td>
</tr>
<tr>
<td>arrest</td>
<td>逮捕，拘留</td>
</tr>
<tr>
<td>assess</td>
<td>评估</td>
</tr>
<tr>
<td>*attribute</td>
<td>把…归因于</td>
</tr>
<tr>
<td>bacteria</td>
<td>细菌，bacterium的复数</td>
</tr>
<tr>
<td>ballot</td>
<td>投票表决</td>
</tr>
<tr>
<td>barrel</td>
<td>一桶</td>
</tr>
<tr>
<td>antenna</td>
<td>天线</td>
</tr>
<tr>
<td>appal</td>
<td>使惊骇</td>
</tr>
<tr>
<td>appendix</td>
<td>（文书）的附录，阑尾</td>
</tr>
<tr>
<td>*appraisal</td>
<td>评价，评估</td>
</tr>
<tr>
<td>apt</td>
<td>聪明的，有做某事的倾向</td>
</tr>
<tr>
<td>arbitrary</td>
<td>主观任意的，专横独行的</td>
</tr>
<tr>
<td>artery</td>
<td>主干道，动脉，要道</td>
</tr>
<tr>
<td>ascend</td>
<td>上升</td>
</tr>
<tr>
<td>*ascertain</td>
<td>查明，弄清</td>
</tr>
<tr>
<td>assassinate</td>
<td>暗杀，刺杀</td>
</tr>
<tr>
<td>aural</td>
<td>听力的</td>
</tr>
<tr>
<td>aviation</td>
<td>航飞，飞行，航空制造业</td>
</tr>
<tr>
<td>bail</td>
<td>保释金</td>
</tr>
<tr>
<td>balcony</td>
<td>阳台</td>
</tr>
<tr>
<td>bald</td>
<td>秃的</td>
</tr>
<tr>
<td>*bandage</td>
<td>绷带</td>
</tr>
<tr>
<td>banner</td>
<td>旗帜</td>
</tr>
<tr>
<td>barren</td>
<td>贫瘠的，不孕的，无价值无结果的</td>
</tr>
<tr>
<td>basement</td>
<td>地下室</td>
</tr>
<tr>
<td>basin</td>
<td>盆，脸盆，内海，盆地</td>
</tr>
<tr>
<td>*bat</td>
<td>球拍击球</td>
</tr>
<tr>
<td>batch</td>
<td>一批</td>
</tr>
</tbody></table>
<blockquote>
<p>attribute to 总是记成致力于，应该是把…归因于</p>
</blockquote>
<blockquote>
<p>appraisal评价，评估</p>
</blockquote>
<blockquote>
<p>ascertain查明，查清，不是确定的意思（意思也比较相近吧）</p>
</blockquote>
<blockquote>
<p>bandage绷带 not carriage 马车</p>
</blockquote>
<blockquote>
<p>bat球拍</p>
</blockquote>
]]></content>
      <tags>
        <tag>-vocabulary</tag>
      </tags>
  </entry>
  <entry>
    <title>vocabularyA</title>
    <url>/2019/12/16/vocabularA/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>英</th>
<th>中</th>
</tr>
</thead>
<tbody><tr>
<td>abide</td>
<td>逗留，遵守，忍受</td>
</tr>
<tr>
<td>absord</td>
<td>吸收，消耗，承担</td>
</tr>
<tr>
<td>accuse</td>
<td>控告，指责</td>
</tr>
<tr>
<td>allowance</td>
<td>津贴，零用钱，减价，允许</td>
</tr>
<tr>
<td>*abdomen</td>
<td>腹</td>
</tr>
<tr>
<td>accessory</td>
<td>配件，配饰，辅音</td>
</tr>
<tr>
<td>acrobat</td>
<td>特技演员，变化无常的人</td>
</tr>
<tr>
<td>adjacent</td>
<td>相邻的</td>
</tr>
<tr>
<td>affection</td>
<td>爱情，爱慕，慈爱</td>
</tr>
<tr>
<td>affluent</td>
<td>富裕的</td>
</tr>
<tr>
<td>agitate</td>
<td>搅动，煽动，使不安</td>
</tr>
<tr>
<td>aisle</td>
<td>教堂过道通道</td>
</tr>
<tr>
<td>*alienate</td>
<td>挑拨离间</td>
</tr>
<tr>
<td>allegiance</td>
<td>拥护，忠诚</td>
</tr>
<tr>
<td>alloy</td>
<td>合金</td>
</tr>
<tr>
<td>ambassador</td>
<td>大使</td>
</tr>
<tr>
<td>*amend</td>
<td>修改，修订</td>
</tr>
<tr>
<td>amplifier</td>
<td>扬声器</td>
</tr>
<tr>
<td>anguish</td>
<td>痛苦</td>
</tr>
<tr>
<td>ankle</td>
<td>脚踝</td>
</tr>
</tbody></table>
<blockquote>
<p>PS原来md中的表格是一定要有表头的</p>
</blockquote>
<blockquote>
<p>amend 修改修订<br>abdomen腹部<br>记混了，注意区别</p>
</blockquote>
<blockquote>
<p>alienate挑拨离间<br>antenna天线<br>记混了，注意区别</p>
</blockquote>
]]></content>
      <tags>
        <tag>-vocabulary</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构关键词索引（八）</title>
    <url>/2019/12/13/Key-Words-in-Date-Structure8/</url>
    <content><![CDATA[<h1 id="第八章-高级搜索树"><a href="#第八章-高级搜索树" class="headerlink" title="第八章 高级搜索树"></a>第八章 高级搜索树</h1><a id="more"></a>
<h3 id="持久性结构（persistent-structure）P204"><a href="#持久性结构（persistent-structure）P204" class="headerlink" title="持久性结构（persistent structure）P204"></a>持久性结构（persistent structure）<em>P204</em></h3><p>红黑树不仅能够保持全树的适度平衡，从而有效地控制单次操作的时间成本，而且可以将每次重平衡过程执行的结构调整，控制在常数次以内。后者也是该树有别于其它变种的关键特性，它不仅保证了红黑树更高的实际计算效率，更为持久性结构之类高级数据结构的实现，提供了直接而有效的方法。</p>
<h3 id="伸展树（splay-tree）P204"><a href="#伸展树（splay-tree）P204" class="headerlink" title="伸展树（splay tree）P204"></a>伸展树（splay tree）<em>P204</em></h3><p>伸展树也是平衡二叉搜索树的一种形式，相对于前者，后者的实现更为简洁。伸展树无需时刻都严格地保持全树的平衡，但却能够在任何足够长的真实操作序列中，保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构，做任何附加的要求或改动，更不需要记录平衡因子或高度之类的额外信息，故适用于更广的范围。</p>
<h3 id="数据的局部性（data-locality）P204"><a href="#数据的局部性（data-locality）P204" class="headerlink" title="数据的局部性（data locality）P204"></a>数据的局部性（data locality）<em>P204</em></h3><p>1）刚被访问过的元素，极有可能在不久之后再次被访问到。<br>2）将被访问的下一元素，极有可能就处于不久之前被访问过的某个元素的附近<br>就二叉搜索树而言，数据局部性具体表现为：<br>1）刚刚被访问过的节点，极有可能在不久之后再次被访问到<br>2）将被访问的下一节点，极有可能就处于不久之前被访问过的某个节点的附近</p>
<h3 id="伸展（splaying）P205"><a href="#伸展（splaying）P205" class="headerlink" title="伸展（splaying）P205"></a>伸展（splaying）<em>P205</em></h3><p>没访问过一个节点之后，随即反复地以它的父节点为轴，经适当的旋转将其提升一层，直至最终称为树根。随着节点的逐层上升，两侧子树的结构也不断调整。故这一过程也形象地称作伸展，而采用这一调整策略的二叉搜索树也因此得名。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构关键词索引（七）</title>
    <url>/2019/12/13/Key-Words-in-Date-Structure7/</url>
    <content><![CDATA[<h1 id="第七章-搜索树"><a href="#第七章-搜索树" class="headerlink" title="第七章 搜索树"></a>第七章 搜索树</h1><a id="more"></a>
<h3 id="搜索（search）、词条（entry）、关键码（key）P183"><a href="#搜索（search）、词条（entry）、关键码（key）P183" class="headerlink" title="搜索（search）、词条（entry）、关键码（key）P183"></a>搜索（search）、词条（entry）、关键码（key）<em>P183</em></h3><p>所谓的查找或搜索，指从一组数据对象中找出符合特定条件者，这是构建算法的一种基本而重要的操作。其中的数据对象，统一地表示和实现为词条的形式，不同词条之间，依照各自的关键码彼此区分。</p>
<h3 id="寻关键码访问（call-by-key）P183"><a href="#寻关键码访问（call-by-key）P183" class="headerlink" title="寻关键码访问（call-by-key）P183"></a>寻关键码访问（call-by-key）<em>P183</em></h3><p>与此前的“寻秩访问”和“寻位置访问”等完全不同，这一新的访问方式，与数据对象的物理位置或逻辑次序均无关，实际上，查找的过程与结果，仅仅取决于目标对象的关键码，故这种方式亦称作寻关键码访问。</p>
<h3 id="二叉搜索树（binary-search-tree）P184"><a href="#二叉搜索树（binary-search-tree）P184" class="headerlink" title="二叉搜索树（binary search tree）P184"></a>二叉搜索树（binary search tree）<em>P184</em></h3><p>在所谓的二叉搜索树中，处处都满足顺序性：任一节点r的左（右）子树中，所有节点（若存在）均不大于（不小于）r。任一节点r的左（右）子树中，所有节点（若存在）均小于（大于）r。任何一棵二叉树是二叉搜索树，当且仅当其中序遍历序列单调非降。</p>
<h3 id="随机生成（randomly-generated）P191"><a href="#随机生成（randomly-generated）P191" class="headerlink" title="随机生成（randomly generated）P191"></a>随机生成（randomly generated）<em>P191</em></h3><p>不妨设各节点对应于n个互异关键码{e1,e2,…,en}。于是按照每一排列：<br>σ = {ei1,ei2,…,ein}<br>只要从空树开始，通过依次执行insert（eik），即可得到这n个关键码的一棵二叉搜索树T（σ）。与随机排列σ如此对应的二叉搜索树T（σ），称作由σ“随机生成”。</p>
<h3 id="随机组成（"><a href="#随机组成（" class="headerlink" title="随机组成（"></a>随机组成（</h3><p>randomly composed）<em>P191</em><br>另一种随机策略是，假定n个互异节点同时给定，然后在遵守顺序性的前提下，随机确定它们之间的拓扑联系。如此，称二叉搜索树由这组节点“随机组成”。</p>
<h3 id="平衡二叉树（balanced-binary-search-tree，BBST）P192"><a href="#平衡二叉树（balanced-binary-search-tree，BBST）P192" class="headerlink" title="平衡二叉树（balanced binary search tree，BBST）P192"></a>平衡二叉树（balanced binary search tree，BBST）<em>P192</em></h3><p>在渐进意义下适当放松标准之后的平衡，称作适度平衡。<br>比如，将树高限制为“渐进地不超过O（logn），则下节将要介绍的AVL树，以及下一章将要介绍的伸展树、红黑树、kd-<br>树等，都属于适度平衡。这些变种，因此也都可归于平衡二叉搜索树之列。</p>
<h3 id="AVL树（AVL-tree）P194"><a href="#AVL树（AVL-tree）P194" class="headerlink" title="AVL树（AVL tree）P194"></a>AVL树（AVL tree）<em>P194</em></h3><p>通过合理设定适度平衡的标准，并借助等价变换，AVL树可以实现近乎理想的平衡。在渐进意义下，AVL树可以始终将其高度控制在O（logn）以内，从而保证每次查找、插入或删除操作，均可在O（logn）的时间内完成。</p>
<h3 id="平衡因子（balance-factor）P194"><a href="#平衡因子（balance-factor）P194" class="headerlink" title="平衡因子（balance factor）P194"></a>平衡因子（balance factor）<em>P194</em></h3><p>任一节点v的平衡因子定义为“其左、右子树的高度差”，即<br>    balFac（v） =  height（lc（v））-height（rc（v））<br>本书中空树高度取-1，单节点子树（叶节点）高度取0，与以上定义没有冲突，所谓AVL树，即平衡因子受限的二叉搜索树——其中各节点平衡因子的绝对值均不超过1。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构关键词索引（六）</title>
    <url>/2019/12/11/Key-Words-in-Date-Structure6/</url>
    <content><![CDATA[<h1 id="第六章-图"><a href="#第六章-图" class="headerlink" title="第六章 图"></a>第六章 图</h1><a id="more"></a>
<h3 id="非线性结构（non-linear-structure）P150"><a href="#非线性结构（non-linear-structure）P150" class="headerlink" title="非线性结构（non-linear structure）P150"></a>非线性结构（non-linear structure）<em>P150</em></h3><p>相互之间均可能存在二元关系的一组对象，从数据结构的角度分类，属于非线性结构。</p>
<h3 id="图（graph）、顶点（vertex）、边（edge）P150"><a href="#图（graph）、顶点（vertex）、边（edge）P150" class="headerlink" title="图（graph）、顶点（vertex）、边（edge）P150"></a>图（graph）、顶点（vertex）、边（edge）<em>P150</em></h3><p>所谓的图，可以描述为G=（V，E），其中集合V中的元素称为顶点，集合E中的元素分别对应于V中的某一对顶点（v，u），表示它们之间存在的某种关系，称为边。</p>
<h3 id="无向边（undirected-edge）、有向边（directed-edge）P150起点（origin）、尾顶点（tail）、终点（destination）、头顶点（head）P151"><a href="#无向边（undirected-edge）、有向边（directed-edge）P150起点（origin）、尾顶点（tail）、终点（destination）、头顶点（head）P151" class="headerlink" title="无向边（undirected edge）、有向边（directed edge）P150起点（origin）、尾顶点（tail）、终点（destination）、头顶点（head）P151"></a>无向边（undirected edge）、有向边（directed edge）<em>P150<em>起点（origin）、尾顶点（tail）、终点（destination）、头顶点（head）</em>P151</em></h3><p>若边（u，v）对应的顶点u、v的次序无所谓，则被称为无向边；边（u，v）对应的顶点u、v有次序，则被称为有向边。这里约定（u，v）从u指向v，其中u称为该边的起点或者尾顶点，v称为该边的终点或者头顶点。</p>
<h3 id="无向图（undirected-graph简称undigraph）、有向图（directed-graph简称digraph）、混合图（mixed-graph）P151"><a href="#无向图（undirected-graph简称undigraph）、有向图（directed-graph简称digraph）、混合图（mixed-graph）P151" class="headerlink" title="无向图（undirected graph简称undigraph）、有向图（directed graph简称digraph）、混合图（mixed graph）P151"></a>无向图（undirected graph简称undigraph）、有向图（directed graph简称digraph）、混合图（mixed graph）<em>P151</em></h3><p>若E中各边均无方向，则G被称为无向图；E中各边均有方向，则G被称为有向图；E中各边有些有方向，有些没有方向则G被称为混合图。</p>
<h3 id="度数（degree）、邻接（adjacent）、关联（incident）P151"><a href="#度数（degree）、邻接（adjacent）、关联（incident）P151" class="headerlink" title="度数（degree）、邻接（adjacent）、关联（incident）P151"></a>度数（degree）、邻接（adjacent）、关联（incident）<em>P151</em></h3><p>对于任何边e=（u，v），称顶点u，v相互邻接，互为邻居。而它们都与边e彼此关联。在无向图中，顶点u的关联的边数称为度数，记作deg（u）。</p>
<h3 id="出边（outgoing-edge）、入边（ingoing-edge）、出度（out-degree）、入度（in-degree）P151"><a href="#出边（outgoing-edge）、入边（ingoing-edge）、出度（out-degree）、入度（in-degree）P151" class="headerlink" title="出边（outgoing edge）、入边（ingoing edge）、出度（out-degree）、入度（in-degree）P151"></a>出边（outgoing edge）、入边（ingoing edge）、出度（out-degree）、入度（in-degree）<em>P151</em></h3><p>在有向边e=（u，v）中，e称作u的出边，称作v的入边。v的入边的边数称为入度，记作outdeg（v），出边的边数称为出度，记作indeg（v）。</p>
<h3 id="自环（self-loop）、简单图（simple-graph）P151"><a href="#自环（self-loop）、简单图（simple-graph）P151" class="headerlink" title="自环（self-loop）、简单图（simple graph）P151"></a>自环（self-loop）、简单图（simple graph）<em>P151</em></h3><p>连接于同一顶点之间的边称为自环，没有任何自环的图被称为简单图。</p>
<h3 id="通路（path）P151"><a href="#通路（path）P151" class="headerlink" title="通路（path）P151"></a>通路（path）<em>P151</em></h3><p>所谓路径或通路，就是由m+1个顶点与m条边交替而成的一个序列：<br>    π={v0,e1,v1,e2,v2…,em,vm}<br>且对任何0&lt;i&lt;=m，都有ei=（vi-1，vi），也就是说这些边依次首位相联，其中沿途边的总数m，亦称作通路的长度，记作｜π｜=m。<br>为简化描述，也可依次给出通路沿途的各个顶点，而省略连接于其间的边，即表示为：<br>    π={v0,v1,v2,…vm}</p>
<h3 id="简单通路（simple-path）P152"><a href="#简单通路（simple-path）P152" class="headerlink" title="简单通路（simple path）P152"></a>简单通路（simple path）<em>P152</em></h3><p>尽管通路上的顶点可以重复，但通路上的边不能重复，没有重复的顶点的通路被称作简单通路。</p>
<h3 id="环路（cycle）P152"><a href="#环路（cycle）P152" class="headerlink" title="环路（cycle）P152"></a>环路（cycle）<em>P152</em></h3><p>对于长度m&gt;=1的通路π，若起止顶点相同，即v0=vm，则称作环路，其长度也取作沿途边的总数。</p>
<h3 id="有向无环图（directed-acyclic-graph，DAG）P152"><a href="#有向无环图（directed-acyclic-graph，DAG）P152" class="headerlink" title="有向无环图（directed acyclic graph，DAG）P152"></a>有向无环图（directed acyclic graph，DAG）<em>P152</em></h3><p>无任何环路的有向图被称作有向无环图。</p>
<h3 id="欧拉环路（Eulerian-tour）P152"><a href="#欧拉环路（Eulerian-tour）P152" class="headerlink" title="欧拉环路（Eulerian tour）P152"></a>欧拉环路（Eulerian tour）<em>P152</em></h3><p>经过图中各边一次且恰好一次的环路，称作欧拉环路。当然其长度刚好等于图中总边数e。</p>
<h3 id="哈密尔顿环路（Hamiltonian-tour）P152"><a href="#哈密尔顿环路（Hamiltonian-tour）P152" class="headerlink" title="哈密尔顿环路（Hamiltonian tour）P152"></a>哈密尔顿环路（Hamiltonian tour）<em>P152</em></h3><p>经过图中各顶点一次且恰好一次的环路，称作哈密尔顿环路，其长度也为图中边的总数e。</p>
<h3 id="权重（weight）、带权图（weighted-graph）、带权网络（weighted-net）、网络（net）P152"><a href="#权重（weight）、带权图（weighted-graph）、带权网络（weighted-net）、网络（net）P152" class="headerlink" title="权重（weight）、带权图（weighted graph）、带权网络（weighted net）、网络（net）P152"></a>权重（weight）、带权图（weighted graph）、带权网络（weighted net）、网络（net）<em>P152</em></h3><p>通过一个带权值函数，为每条边e指定一个权重，如wt（e）即为边e的权重。各边均带有权重的图，称作带权图。也称作带权网络，亦可称作网络。记为G（V，E，wt（））。</p>
<h3 id="邻接矩阵（adjacency-matrix）P155"><a href="#邻接矩阵（adjacency-matrix）P155" class="headerlink" title="邻接矩阵（adjacency matrix）P155"></a>邻接矩阵（adjacency matrix）<em>P155</em></h3><p>邻接矩阵是图ADT的最基本实现方式，使用方阵A[n][n]表示由n个顶点构成的图，其中每个单元，各自负责描述一对顶点之间可能存在的邻接关系。<br>对于无权图，存在（不存在）从顶点u到v的边，当且仅当A[u][v]=1(0)。<br>对于有权图，矩阵各单元可从布尔类型改为整型/浮点型，记录所对应边的权重。对于不存在的边统一记为0或∞。</p>
<h3 id="稀疏图（sparse-graph）P158"><a href="#稀疏图（sparse-graph）P158" class="headerlink" title="稀疏图（sparse graph）P158"></a>稀疏图（sparse graph）<em>P158</em></h3><p>在稀疏图中，边数渐进不超过O（n），仅与顶点总数大致相同。</p>
<h3 id="邻接表（adjacency-list）P158"><a href="#邻接表（adjacency-list）P158" class="headerlink" title="邻接表（adjacency list）P158"></a>邻接表（adjacency list）<em>P158</em></h3><p>将邻接矩阵逐行转换为一组列表，即可分别记录各顶点的关联边（或等价地，邻接顶点），这些列表即称为邻接表。</p>
<h3 id="遍历树（traversal-tree）P159"><a href="#遍历树（traversal-tree）P159" class="headerlink" title="遍历树（traversal tree）P159"></a>遍历树（traversal tree）<em>P159</em></h3><p>图的遍历可以理解为，将非线性结构转化为半线性结构的过程，经过遍历而确定的边类型中，最重要的一类即所谓的树边，它们与所有顶点共同构成了原图的一刻支撑树（森林），称作遍历树。</p>
<h3 id="图搜索（graph-search）P159"><a href="#图搜索（graph-search）P159" class="headerlink" title="图搜索（graph search）P159"></a>图搜索（graph search）<em>P159</em></h3><p>图中顶点之间可能存在多条通路，故为避免对顶点的重复访问，在遍历的过程中，通常还要动态地设置各顶点不同的状态，并随着遍历的进程不断地转换状态，直至最后的“访问完毕”。图的遍历更加强调对处于特定状态顶点的甄别和查找，故也称作图搜索。</p>
<h3 id="广度优先搜索（breadth-first-search，BFS）、波峰集（frontier）P159"><a href="#广度优先搜索（breadth-first-search，BFS）、波峰集（frontier）P159" class="headerlink" title="广度优先搜索（breadth-first search，BFS）、波峰集（frontier）P159"></a>广度优先搜索（breadth-first search，BFS）、波峰集（frontier）<em>P159</em></h3><p>广度优先搜索的策略可以概括为：</p>
<blockquote>
<p>越早被访问到的顶点，其邻居越优先被选用。</p>
</blockquote>
<p>于是，始自图中顶点s的BFS搜索，将首先访问顶点s；再依次访问s所有尚未访问到的邻居；再按后者被访问的先后次序，逐个访问它们的邻居；…；如此不断。在所有已经访问到的顶点中，仍有邻居尚未访问者构成所谓的波峰集，于是BFS也可以等效地理解为：</p>
<blockquote>
<p>反复从波峰集中找到最早被访问到的顶点v，若其邻居均已被访问，则将其逐出波峰集；否则，随意挑选出一个尚未被访问到的邻居，并将其加入到波峰集。</p>
</blockquote>
<p>不难发现，将BFS策略用到树中，则等效于层序遍历。</p>
<h3 id="连通分量（connected-component）、可达分量（reachable-component）P159"><a href="#连通分量（connected-component）、可达分量（reachable-component）P159" class="headerlink" title="连通分量（connected component）、可达分量（reachable component）P159"></a>连通分量（connected component）、可达分量（reachable component）<em>P159</em></h3><p>因为BFS不会遗漏掉每个刚被访问顶点的任何邻居，故对于无向图必能覆盖s所属的连通分量，对于有向图必能覆盖以s为起点的可达分量。</p>
<h3 id="广度优先搜索树（BFS-tree）P160"><a href="#广度优先搜索树（BFS-tree）P160" class="headerlink" title="广度优先搜索树（BFS tree）P160"></a>广度优先搜索树（BFS tree）<em>P160</em></h3><p>BFS（）遍历结束后，所有访问过的顶点通过一个指针依次联接，从整体上给出了原图某一连通或可达域的一棵遍历树，称作广度优先搜索树，简称为BFS树。</p>
<h3 id="BFS森林（BFS-forest）P161"><a href="#BFS森林（BFS-forest）P161" class="headerlink" title="BFS森林（BFS forest）P161"></a>BFS森林（BFS forest）<em>P161</em></h3><p>BFS（s）将覆盖起始顶点s所属的连通分量或可达分量，但是无法抵达此外的顶点。在逐个检查顶点的过程中，只要发现某一顶点尚未被发现，则意味着其所属的连通分量或可达分量尚未触及，故可从该顶点出发再次启动BFS（），以遍历其所属的连通分量或可达分量。如此，各次BFS（）调用所得的BFS树构成一个森林，称作BFS森林。</p>
<h3 id="深度优先搜索（Depth-First-Search）P162"><a href="#深度优先搜索（Depth-First-Search）P162" class="headerlink" title="深度优先搜索（Depth-First Search）P162"></a>深度优先搜索（Depth-First Search）<em>P162</em></h3><p>深度优先搜索选取下一个顶点的策略可以概括为：</p>
<blockquote>
<p>优先选取最后一个被访问到的顶底的邻居</p>
</blockquote>
<p>以顶点s为基点的DFS搜索，首先访问顶点s；再从s所有尚未访问到的邻居中任取其一，并以之为基点，递归地执行DFS搜索，故各顶点被访问到的次序，类似于树的先序遍历；而各顶点被访问完毕的次序类似于树的后序遍历。</p>
<h3 id="树边（tree-edge）P162"><a href="#树边（tree-edge）P162" class="headerlink" title="树边（tree edge）P162"></a>树边（tree edge）<em>P162</em></h3><p>若顶点u尚处于未发现UNDISCOVER状态，则将（v，u）归类为树边。并将v记作u的父节点，此后，便可将u作为当前顶点，继续递归地遍历。</p>
<h3 id="后向边（back-edge）P163"><a href="#后向边（back-edge）P163" class="headerlink" title="后向边（back edge）P163"></a>后向边（back edge）<em>P163</em></h3><p>若顶点u处于DISCOVER状态，则意味着在此处发现一个有向环路。此时，在DFS遍历树中u必为v的祖先，故应将边（v，u）归类为后向边。</p>
<h3 id="活跃期（active-duration）P163"><a href="#活跃期（active-duration）P163" class="headerlink" title="活跃期（active duration）P163"></a>活跃期（active duration）<em>P163</em></h3><p>这里为每个顶点v都记录了被发现的和访问完成的时刻，对应的时间区间[dTime（v），fTime（v）]均称为v的活跃期。</p>
<h3 id="前向边（foward-edge）、跨边（cross-edge）P163"><a href="#前向边（foward-edge）、跨边（cross-edge）P163" class="headerlink" title="前向边（foward edge）、跨边（cross edge）P163"></a>前向边（foward edge）、跨边（cross edge）<em>P163</em></h3><p>对于有向图，顶点u还可能处于VISITED状态，此时只要对比v与u的活跃期，即可判定在DFS树中v是否为u的祖先。若是，则边（v，u）应归类为前向边，否则二者必然来自相互独立的两个分支，边（v，u）应归类为跨边。</p>
<h3 id="深度优先搜索树（DFS-tree）、深度优先搜索森林（DFS-tree）P163"><a href="#深度优先搜索树（DFS-tree）、深度优先搜索森林（DFS-tree）P163" class="headerlink" title="深度优先搜索树（DFS tree）、深度优先搜索森林（DFS tree）P163"></a>深度优先搜索树（DFS tree）、深度优先搜索森林（DFS tree）<em>P163</em></h3><p>DFS（s）返回后，所有访问过的顶点通过一个指针依次联接，从整体上给出了顶点所属连通或可达分量的一棵遍历树，称作深度遍历树。同属若有其它连通或可达分量，则可以其中任何顶点作为基点，再次启动DFS搜索。最终，经过各次DFS搜索生成的一系列DFS树，构成了DFS森林。</p>
<h3 id="拓扑排序（topological-sorting）P166"><a href="#拓扑排序（topological-sorting）P166" class="headerlink" title="拓扑排序（topological sorting）P166"></a>拓扑排序（topological sorting）<em>P166</em></h3><p>每一顶点都不会通过边，指向其在此序列中的前驱顶点，这样的一个线性序列称作原有向图的一个拓扑。</p>
<h3 id="切割节点（cut-vertex）、关节点（articulation-vertex）P168"><a href="#切割节点（cut-vertex）、关节点（articulation-vertex）P168" class="headerlink" title="切割节点（cut vertex）、关节点（articulation vertex）P168"></a>切割节点（cut vertex）、关节点（articulation vertex）<em>P168</em></h3><p>考察无向图G。若删除顶点v后G所包含的连通域增多，则v称作切割节点或关节点。</p>
<h3 id="双连通域（bi-connected-component）P168"><a href="#双连通域（bi-connected-component）P168" class="headerlink" title="双连通域（bi-connected component）P168"></a>双连通域（bi-connected component）<em>P168</em></h3><p>任一无向图都可视作由若干个极大的双连通子图组合而成，这样的每一字图都称作原图的一个双连通域。</p>
<h3 id="最高祖先（highest-connected-ancestor，HCA）P169"><a href="#最高祖先（highest-connected-ancestor，HCA）P169" class="headerlink" title="最高祖先（highest connected ancestor，HCA）P169"></a>最高祖先（highest connected ancestor，HCA）<em>P169</em></h3><p>只要在DFS搜索过程中记录并更新各顶点v所能（经由后向边）连通的最高祖先，hca[v]，即可及时确定关节点，并报告对应的双连通域。</p>
<h3 id="优先级搜索（priority-first-search，PFS）、最佳优先搜索（best-first-search，BFS）P173"><a href="#优先级搜索（priority-first-search，PFS）、最佳优先搜索（best-first-search，BFS）P173" class="headerlink" title="优先级搜索（priority-first search，PFS）、最佳优先搜索（best-first search，BFS）P173"></a>优先级搜索（priority-first search，PFS）、最佳优先搜索（best-first search，BFS）<em>P173</em></h3><p>每一种选取策略都等效于，给所有顶点赋予不同的优先级，而且随着算法的推进不断调整，而且随着算法的推进不断调整；而每一步迭代所取的顶点，都是当时的优先级最高者。按照这种理解，包括BFS和DFS在内的几乎所有图搜索，都可以纳入统一的框架。鉴于优先级在其中所扮演的关键角色，故亦称作优先级搜索，或最佳优先搜素。</p>
<h3 id="最小支撑树（minimum-spanning-tree，MST）P174"><a href="#最小支撑树（minimum-spanning-tree，MST）P174" class="headerlink" title="最小支撑树（minimum spanning tree，MST）P174"></a>最小支撑树（minimum spanning tree，MST）<em>P174</em></h3><p>若图G为一带权网络，则每一棵支撑树的成本（cost）即为其所采用各边权重的总和，在G的所有支撑树中，成本最低者称作最小支撑树。</p>
<h3 id="跨越边（crossing-edge）、桥（bridge）P175"><a href="#跨越边（crossing-edge）、桥（bridge）P175" class="headerlink" title="跨越边（crossing edge）、桥（bridge）P175"></a>跨越边（crossing edge）、桥（bridge）<em>P175</em></h3><p>图G=（V；E）中，顶点集V的任一非平凡子集U及其补集V\U<br>都构成G的一个割（cut），记为（U；V\U)。若边uv满足u∈U且v不属于U，则称为该割的一条跨越边，因此类边联接于V及其补集之间，故亦形象地称作该割的一座桥。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>2010Text3</title>
    <url>/2019/12/09/2010Text3/</url>
    <content><![CDATA[<p>在他的书《引爆点》中，马克姆·格莱德维尔声称：“社会流行很大程度上是由一小部分特殊<del>领导者</del>少数人个体的行为<del>引起的</del><font color=LightCoral>推动的</font>，他们被称为‘有影响力的人’，他们通常信息充足、<del>或者（翻译不出）</del><font color=LightCoral>很有说服力或者人脉广阔</font>。<br>这个想法<font color=LightCoral>在直观上很让人信服</font>，但它并没有解释思想是如何传播的。</p>
<p>这种所谓的有影响力的人的重要性来源于一个<del>误传的</del><font color=LightCoral>貌似有道理的</font>、但是未经证实的被称为“两部流动交流”的理论——信息从媒体传向有影响力的人，然后从有影响力的人传向其他所有人。<br><del>市场工作者</del><font color=LightCoral>营销人员</font>已经接受了这种两步流动理论，因为这个理论暗示了<del>如果</del><font color=LightCoral>只要</font>他们能找到然后影响这些有影响力的人，这些精选出来的人将会完成他们的大部分任务。<br>这个理论同样也似乎解释了突然和出乎意料的<del>外表</del><font color=LightCoral>时式</font>、品牌或者社区<font color=LightCoral>地段</font>的流行。<br>在许多类似的事例中，一个粗略的调查发现无论这些是什么，在其他人注意到之前，一些小的团体已经在穿着、推进、或者发展它们了。<br>这类的奇逸证据较好地对应了只有少数特定人群才能主宰潮流的思想。</p>
<p>然而，在他们最近的工作中，一些研究者逐渐发现有影响力的人对社会流行的影响力远远小于普遍的<del>期望</del><font color=LightCoral>猜想/假定/假设</font>。<br>事实上，他们似乎完全没有被需要。</p>
<p>研究人员的结论来源于一个简单的关于社会影响的观察：对像奥普拉·温弗瑞这样的几个社会名流的期盼，他们的外在表现主要就是一个媒体的功能，而不是人与人之间的影响，甚至于是在流行上最有影响力的成员，也不能与很多的外人相互影响。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-English</tag>
      </tags>
  </entry>
  <entry>
    <title>2010Text2</title>
    <url>/2019/12/09/2010Text2/</url>
    <content><![CDATA[<p>不知不觉从英语大佬变成了英语弱鸡</p>
<a id="more"></a>
<p>在过去的十年里，数以千计的专利授予给了所谓的商业模式。亚马逊的“单击”的在线支付系统收到了一种<font color=LightCoral>项</font>专利。美林的资产配置策略得到了法律保护。一位发明家得到了<font color=LightCoral>一种</font>提箱技术的专利。</p>
<p>现在美国国家最高专利法院<font color=LightCoral>庭</font>似乎已经完全做好了收回<font color=LightCoral>减少</font>商业模式专利<font color=LightCoral>数量</font>的准备，这些专利<font color=LightCoral>自十年前</font>第一次被批准的时候就充满了争议。<br>在一项<font color=LightCoral>让</font>知识产权律师喋喋<font color=LightCoral>议论纷纷的</font>的运动中<font color=LightCoral>举措中</font>，美国联邦巡回上诉法庭宣称，他们将用一个特殊的例案来制造一个对商业方法专利全面的重审。<br>来自密苏里大学法学院的<del>丹尼斯</del><font color=LightCoral>丹尼斯·D·克劳奇说</font>，我们熟知的比尔斯基的案件是一个“大事件”，因为这个事件有消除<del>整个专利类型</del><font color=LightCoral>整类专利</font>的潜在可能性。</p>
<blockquote>
<p><font color=LightCoral>此处存疑，某某某说能否提前，是不是引号里的内容都是这个人说的？</font></p>
</blockquote>
<p>对于商业方式的专利申请的限制可能会发生<font color=LightCoral>戏剧性的</font>180度的大转变，因为正是联邦巡回法庭它本身在1998年对于所谓的<del>洲街道法案</del><font color=LightCoral>“道富银行案”</font><del>决定</del><font color=LightCoral>裁决中</font><br><del>生成了</del><font color=LightCoral>引入了</font>这<del>样</del><font color=LightCoral>类</font>的专利，批准了<font color=LightCoral>一项</font><del>相互集资</del><font color=LightCoral>共同基金资产筹集</font>方法的专利。</p>
<blockquote>
<p>注意翻译时的单复数的使用，还有不要漏次掉词</p>
</blockquote>
<p><del>这</del><font color=LightCoral>那</font>项裁决导致了商业方法专利<del>综卷</del><font color=LightCoral>综卷</font>的激增，最初是<del>由</del>新兴互联网公司试图去标注出特定类型的网络交易的独家占有权。</p>
<blockquote>
<p>注意细节，以及中文的准确性</p>
</blockquote>
<p>之后，越来越多的<del>建立起的</del><font color=LightCoral>老牌</font>公司竞相在它们的卷宗上加上这类专利，<del>好像只有通过这种对抗竞争对手的防守举措他们才能一击制胜</del><font color=LightCoral>哪怕只是作为一项防御性措施以防范可能先发制人的竞争对手</font>。</p>
<blockquote>
<p>if only as a defensive move against rivals that might beat them to the punch.注意if only … 是哪怕…. ，that后面的从句修饰rivals，as是以…的方式。beat them to the punch 先发制人，翻译成一击制胜也可以。注意翻译的地道性。</p>
</blockquote>
<p>在2005年，一份法庭卷宗中标注了IBM被授予了300多项商业方法专利，尽管它被怀疑这些授予的专利是否存在法律依据。<br>同样地，一些华尔街投资公司用理财产品的专利把自己武装起来，尽管它们在法庭案件中站在违背常理的那边。</p>
<p>比尔斯基的案件涉及<font color=LightCoral>一项</font>到在能源市场中规避风险的方法专利申请。<br>联邦巡回法庭颁布了一份不寻常的<del>序列声明</del><font color=LightCoral>指令</font>，<del>在这份声明当中</del><font color=LightCoral>宣称</font>这个案件将会被12位法官听证，而不是典型的三人小组，并且，还有个它想重新评估的问题就是，是否应该重新定夺“富街银行案件”中的裁决。</p>
<blockquote>
<p>这里句子的划分出现重大错误！！！The federal Circuit issued an unusual order stating that the case would be heard by all 12 of the court’s judges.其中stating是作为动词，对order（n.指令）的修饰。而非order stating作为一个组合名词。</p>
</blockquote>
<p>联邦巡回法庭的这一举措带来的结果是最高法庭作出一系列决定收缩了对专利持有者的保护范围。</p>
<blockquote>
<p>理解错误，come in…在…之后，故正确翻译应该是，联邦巡回法庭的这一举措带紧随是最高法庭作出一系列决定收缩了对专利持有者的保护范围的决定之后。</p>
</blockquote>
<p>例如去年四月，法官们表示太多的<del>明显的</del>专利都被<del>提高到</del><font color=LightCoral>授予了</font><del>所谓</del><font color=LightCoral>平平无奇的</font>“发明”的高度上。</p>
<blockquote>
<p>obvious是在修饰发明，并非专利，并且要转译为“平平无奇”</p>
</blockquote>
<p><del>一位专利大法官兼乔治华盛顿大学法学院的教授哈罗德·C·魏格纳说</del><font color=LightCoral>身兼专利律师和…的XXX说</font>，联邦巡回法庭上的法官们都在对最高法庭提出的“反专利”的形势作出回应。</p>
<blockquote>
<p>这里可以翻译成身兼…和…的XXX说，原来翻译不太通畅。attorney是代理律师的意思，不是大法官。</p>
</blockquote>
<p><font color=LightCoral>翻译得还行，后面比较顺畅，我可真牛逼。</font></p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-English</tag>
      </tags>
  </entry>
  <entry>
    <title>C++基础知识（一）</title>
    <url>/2019/12/07/C-1/</url>
    <content><![CDATA[<h1 id="第7章-类的继承与派生"><a href="#第7章-类的继承与派生" class="headerlink" title="第7章 类的继承与派生"></a>第7章 类的继承与派生</h1><p>C++中有一个很重要的思想就是类的思想，这是它与面向过程的编程思想中很大的不同。它可以通过抽象和分类模拟和实现生活中的一些东西，类与对象的关系恰当地反应了个体与同类群体之间共同特征之间的关系。<br>但是我们进一步的观察这个世界的时候会发现，不同的事物之间不是独立的，往往是相互关联的，比如父亲和孩子，它们之间有不同的地方也有相似的地方，并且两者之间有一种继承的关系。自行车和汽车有共同的一个更抽象的概念——交通工具类，但是它们之间的形态、功能又各有各的不同。<br>C++中就为我们提供了一种用来描述这种关系的方法——类的派生和继承。在父类上提供更抽象、更基础的定义，在子类上提供更具体、更详细的定义。<br>类的派生和继承有什么样的作用和好出呢？第一是能够客观的描述上述在现实生活中存在的类之间的一种抽象的联系和关系；第二是从功利的方面来将，可以实现代码的重用。在别人已经研究的类的基础上对代码进行扩充，可以大大减少我们编写代码的量。</p>
<ul>
<li><p>派生新类的过程包括三个步骤：<br>吸收已有类的成员<br>调整已有类的成员<br>添加新的成员</p>
</li>
<li><p>本章围绕派生过程将讨论<br>不同继承方式下基类成员的访问控制问题、添加构造和析构函数<br>接着将讨论在更为复杂的继承关系中，类成员的唯一标示和访问问题<br>最后给出两个类的继承的实例：主选高斯消去法求线性方程组和一个公司的人员管理系统</p>
<a id="more"></a>
<h2 id="类的继承与派生"><a href="#类的继承与派生" class="headerlink" title="类的继承与派生"></a>类的继承与派生</h2><h3 id="继承关系举例"><a href="#继承关系举例" class="headerlink" title="继承关系举例"></a>继承关系举例</h3><p>类的继承和派生的层次结构，对应于现实生活中的对事物进行分类、分析和认识的过程。在树状的分类中，最上层的具有最高的抽象性，最下层的具有最高的具体性。<br>所谓继承就是从先辈处得到属性和行为特征。类的继承，就是新的类从已有类那里得到已有的特性，反过来看，类的派生就是从已有类那里得到已有特性从而形成新的类。原有类被称为<font color=LightCoral>基累</font>或者<font color=LightCoral>父类</font>，产生新的类被称为<font color=LightCoral>派生类</font>或者<font color=LightCoral>子类</font>。</p>
<h3 id="派生类的定义"><a href="#派生类的定义" class="headerlink" title="派生类的定义"></a>派生类的定义</h3><p>🌰</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Derived:public Base1,private Base2&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derived();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Derived();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></li>
<li><p>单继承与多继承<br>其中base1、base2是基类，derived是派生类。由上可知，一个派生类可以有多个基类，这种情况称为多继承。一个派生类只有一个基类，这种情况被称为单继承。<br>单继承和多继承是对于派生类来说的，派生类有多个基类，就是多继承，派生类只有一个基类就是单继承。就算一个基类派生出来了多个派生类，只要派生类只继承了他这一个基类，这些派生类就是单继承。</p>
</li>
<li><p>直接继承和间接继承<br>在族类中，直接参与派生出某类的基类称为<font color=LightCoral>直接基类</font>，基类的基类甚至更高的基类被称为<font color=LightCoral>间接基类</font>。</p>
</li>
<li><p>继承方式<br>继承方式规定了如何访问从基类继承的成员。每一个“继承方式”只限定紧随其后的基类。</p>
</li>
<li><p>派生类成员<br>派生类成员是指除了从基类继承而来的所有成员之外新增的数据和函数成员。</p>
</li>
</ul>
<h3 id="派生类生成过程"><a href="#派生类生成过程" class="headerlink" title="派生类生成过程"></a>派生类生成过程</h3><ul>
<li>吸收基类成员<br>吸收除了基类中除了构造函数和析构函数之外的所有非静态成员。</li>
<li>改造基类成员<br>对基类的改造包括两个方面，一个是基类成员函数的访问控制问题，主要依靠定义时的继承方式来控制，另一个是对基类数据或者韩式的覆盖或隐藏，覆盖在后面介绍，隐藏就是简单地在派生类中声明一个和某基类成员同名的新成员（如果是成员函数，则参数表也要相同，参数不同属于重载），派生类的新成员就隐藏了外层同名成员。在派生类中或者通过派生类的对象就只能访问到派生类中的同名成员，这就叫做同名隐藏。</li>
<li>添加新的成员<br>在派生的过程中，基类的构造函数和析构函数是不能被继承的，因此需要实现一些特别的初始化和扫尾清理工作，即在派生类中加入新的构造和析构函数。<br>本章的内容基本上是按照这三个步骤来组织的，第一步实际上在定义派生类之后就自动完成了，我们无法干预，也不作讨论。第二步中着重学习不同继承方式下的基类成员的访问和控制问题，第三步重点放在构造函数和析构函数上，其他一般成员函数添加和之前普通类的相同。</li>
</ul>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>类的继承方式也有public、protected、private三重方式：</p>
<h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>当类的继承方式为public继承时，基类的public、protected、private成员还是性质保持不变，在类内基类的公有成员和保护成员可以直接被访问，私有成员在类内不能被访问。在派生类外的对象中，基类的公有成员和保护成员可以被访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Point&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">private:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    float x,y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    float getX()const&#123;return x;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    float getY()const&#123;return y;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void move(int offX,int offY)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x+&#x3D;offX;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        y+&#x3D;offY;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void initPoint(float x&#x3D;0,float y&#x3D;0)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this-&gt;x&#x3D;x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this-&gt;y&#x3D;y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">class Rectangle:public Point&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">private:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    float w,h;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void initRectangle(float x,float y,float w,float h)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        initPoint(x,y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this-&gt;w&#x3D;w;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this-&gt;h&#x3D;h;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    float getH()const&#123;return h;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    float getW()const&#123;return w;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Rectangle rec;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    rec.initRectangle(2, 3, 20, 10);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    rec.move(3,2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout&lt;&lt;&quot;The data of rect(x,y,w,h):&quot;&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout&lt;&lt;rec.getX()&lt;&lt;&quot;,&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&lt;rec.getY()&lt;&lt;&quot;,&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&lt;rec.getW()&lt;&lt;&quot;,&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&lt;rec.getH()&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>The data of rect(x,y,w,h):<br>5,5,20,10</p>
</blockquote>
<p>类Rectangle公有继承了类Point，并在main函数中通过rectangle的对象rec，调用Point类中的公有成员rec.getX(),rec.getY(),rec.move()。这里我们看到了通过共有继承之后对基类的成员的调用。</p>
<h3 id="private"><a href="#private" class="headerlink" title="private"></a>private</h3><p>当类的继承方式为private时，基类的所有成员都被当成private性质被继承，在类内可以访问基类的公有成员和保护成员，在类外的对象中不可访问基类的任何成员。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Point&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">private:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    float x,y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    float getX()const&#123;return x;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    float getY()const&#123;return y;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void move(int offX,int offY)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x+&#x3D;offX;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        y+&#x3D;offY;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void initPoint(float x&#x3D;0,float y&#x3D;0)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this-&gt;x&#x3D;x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this-&gt;y&#x3D;y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">class Rectangle:private Point&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">private:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    float w,h;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void initRectangle(float x,float y,float w,float h)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        initPoint(x,y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this-&gt;w&#x3D;w;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        this-&gt;h&#x3D;h;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    float getH()const&#123;return h;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    float getW()const&#123;return w;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    float getX()const&#123;return Point::getX();&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    float getY()const&#123;return Point::getY();&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void move(int xx,int yy)&#123;Point::move(xx,yy);&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Rectangle rec;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    rec.initRectangle(2, 3, 20, 10);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    rec.move(3,2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout&lt;&lt;&quot;The data of rect(x,y,w,h):&quot;&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout&lt;&lt;rec.getX()&lt;&lt;&quot;,&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&lt;rec.getY()&lt;&lt;&quot;,&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&lt;rec.getW()&lt;&lt;&quot;,&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&lt;rec.getH()&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>运行结果同上，在main函数中无法直接调用基类成员getX、getY、move，要在rectangle类中对其进行调用，注意Rectangle类中getX函数是return Point：：getX（）；</p>
</blockquote>
<h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>当类的继承方式为protected时，基类的公有成员都以保护成员的方式出现在派生类中，派生类内可以直接访问公有成员和保护成员，在类外部通过对象无法直接访问他们。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">protected:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    A a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    a.x&#x3D;5;&#x2F;&#x2F;这里会报错，protected和private一样，不能通过对象直接引用</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">protected:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class B:public A&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void function()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x&#x3D;5;&#x2F;&#x2F;这里不会报错，所以可以说protected就是用来继承使用的；</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>
<p>通过私有和保护继承方式，派生类的对象对基类成员的访问方式是一样的，都是不可以直接访问。那二者的却别在哪里呢？区别就体现在在二次继承的时候，通过私有方式继承的基类的公有和保护成员在第三代类内部是无法被直接访问的，而通过保护方式继承的基类的成员是可以作为保护成员继续被第三代类内继续访问的。<br>总结一下，继承就是把基类的成员吸收过来，据为己有，基类的private都是不能在类内直接访问的。通过不同的继承方式，吸收过来的基类成员在本类中具有了不同的属性。<br>在类外的对象中属性如下：</p>
<table>
<thead>
<tr>
<th>继承方式</th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>可访问</td>
<td>可访问｜不可访问</td>
<td></td>
</tr>
<tr>
<td>protect</td>
<td>不可访问</td>
<td>不可访问</td>
<td>不可访问</td>
</tr>
<tr>
<td>private</td>
<td>不可访问</td>
<td>不可访问</td>
<td>不可访问</td>
</tr>
</tbody></table>
<h2 id="类型兼容规则"><a href="#类型兼容规则" class="headerlink" title="类型兼容规则"></a>类型兼容规则</h2><p>类型兼容规则是指，在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。</p>
<ul>
<li>派生类的对象可以隐含转化为基类对象  b1=d1；</li>
<li>派生类的对象可以初始化基类的引用 B &amp;rb=d1；</li>
<li>派生类的指针可以隐含转化为基类的指针 pb1=&amp;d1；</li>
</ul>
<p>在替代之后，派生类对象就可以作为基类对象使用，但只能使用从基类继承的成员。也就是说，在基类对象出现的任何地方，都可以用派生类的对象来代替。但是只能访问到基类的成员。<br>🌰</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base1&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void display()const&#123;cout&lt;&lt;&quot;Base1::display()&quot;&lt;&lt;endl;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base2:public Base1&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void display()const&#123;cout&lt;&lt;&quot;Base2::display()&quot;&lt;&lt;endl;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Derived:public Base2&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void display()const&#123;cout&lt;&lt;&quot;Derived::display()&quot;&lt;&lt;endl;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void fun(Base1 *ptr)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ptr-&gt;display();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base1 base1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base2 base2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derived derived;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fun(&amp;base1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fun(&amp;base2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fun(&amp;derived);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>Base1::display()<br>Base1::display()<br>Base1::display()</p>
</blockquote>
<h2 id="派生类的构造和析构函数"><a href="#派生类的构造和析构函数" class="headerlink" title="派生类的构造和析构函数"></a>派生类的构造和析构函数</h2><p>在继承的过程中基类的构造函数和析构函数并不会被继承，</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>派生类的构造函数要对继承下来的基类成员和自己类新增的成员进行初始化，构造新的构造函数这些成员进行初始化，一部分参数用来调用基类的构造函数，一部分用来构造本类的新成员。</p>
<blockquote>
<p>派生类名::派生类名(参数表):基类名1(基类1初始化参数表),…,基类名n(基类n初始化参数表),成员对象名1(成员对象1初始化参数表),…,成员对象名m(成员对象m初始化参数表)<br>{<br>    派生类构造函数的其他初始化操作；<br>}</p>
</blockquote>
<p>在构造派生类的对象时，会首先调用基类的构造函数，来初始化它们的数据成员，然后按照构造函数初始化列表中指定的方式初始化派生类新增的成员对象，最后才执行派生类构造函数的函数体。<br>什么时候需要声明派生类的构造函数？如果对基类初始化时，需要调用基类的带有形参表的构造函数时，派生类就必须声明构造函数。如果不需要调用基类带有形参的构造函数，则可以无需构造函数，在派生类的共有函数中对派生类的新增成员进行初始化，也可以啥都不干，系统给派生类生成不带形参的默认构造函数，在其中自己调用没有形参的基类的构造函数。</p>
<p>派生类中构造函数的执行顺序：<br>1）基类的构造函数，按照在继承中的顺序执行<br>2）派生类中新增成员对象的构造顺序，按照在派生类中声明的顺序<br>3）执行派生类的构造函数体中的内容<br>也就是说，构造的顺序和派生类中初始化列表中的顺序是没有关系的，它们初始化的顺序是如上，不会变的。<br>🌰如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base1&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base1(int i)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout&lt;&lt;&quot;Constructing Base1&quot;&lt;&lt;i&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base2&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base2(int j)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout&lt;&lt;&quot;Constructing Base2&quot;&lt;&lt;j&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base3&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base3()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout&lt;&lt;&quot;Constructing Base3*&quot;&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Derived:public Base2,public Base1,public Base3&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derived(int a,int b,int c,int d):Base1(a),member1(b),Base2(c),member2(d)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">private:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base1 member1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base2 member2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base3 member3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derived d(1,2,3,4);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>Constructing Base23<br>Constructing Base11<br>Constructing Base3*<br>Constructing Base12<br>Constructing Base24<br>Constructing Base3*</p>
</blockquote>
<h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>如果在派生类中没有编写复制构造函数，则系统会默认生成一个派生类的复制构造函数，先调用基类的默认复制构造函数，再对派生类中的新增成员一一复制。</p>
<blockquote>
<p>Derived::Derived(const Derived &amp;v):Base(v){…}</p>
</blockquote>
<p>这里用派生类的引用来对基类对象进行复制构造，是应用了类型兼容规则：用派生类的引用来对基类对象进行初始化。</p>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>在派生类中，析构函数也是不能被继承的，所以在派生类中要声明新的析构函数。派生类中的析构函数只需要把本类内新增的成员删除即可，系统会自动调用基类的析构函数。<br>析构的调用顺序与构造时相反：<br>先调用派生类的析构函数，再调用成员类的析构函数，再调用基类的析构函数。<br>即构造和析构的顺序是对称的，举个🌰：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base1&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base1(int i)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout&lt;&lt;&quot;Constructing Base1&quot;&lt;&lt;i&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Base1()&#123;cout&lt;&lt;&quot;Destructing Base1&quot;&lt;&lt;endl;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base2&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base2(int j)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout&lt;&lt;&quot;Constructing Base2&quot;&lt;&lt;j&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Base2()&#123;cout&lt;&lt;&quot;Destructing Base2&quot;&lt;&lt;endl;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base3&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base3()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout&lt;&lt;&quot;Constructing Base3*&quot;&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Base3()&#123;cout&lt;&lt;&quot;Destructing Base3&quot;&lt;&lt;endl;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Derived:public Base2,public Base1,public Base3&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derived(int a,int b,int c,int d):Base1(a),member1(b),Base2(c),member2(d)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Derived()&#123;cout&lt;&lt;&quot;Destructing Derived&quot;&lt;&lt;endl;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">private:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base1 member1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base2 member2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base3 member3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derived d(1,2,3,4);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>Constructing Base23<br>Constructing Base11<br>Constructing Base3*<br>Constructing Base12<br>Constructing Base24<br>Constructing Base3*<br>Destructing Derived<br>Destructing Base3<br>Destructing Base2<br>Destructing Base1<br>Destructing Base3<br>Destructing Base1<br>Destructing Base2</p>
</blockquote>
<h2 id="派生类成员的标识与访问"><a href="#派生类成员的标识与访问" class="headerlink" title="派生类成员的标识与访问"></a>派生类成员的标识与访问</h2><p>在派生类中成员可以分为一下四类：<br>1）<em>不可访问成员</em>从基类继承下来的，基类的私有成员，在派生类中无法访问，更不用说派生类的对象和派生类继续派生的类了，都是无法访问的。<br>2）<em>私有成员</em>可以是从基类继承下来的，也可以是派生类中新增的成员，在派生类的内部可以访问，在派生类的对象中无法访问，在派生类的派生类中为不可访问成员。<br>3）<em>保护成员</em>可以是从基类继承下来的，也可以是派生类中新增的成员，在派生类内部可以访问，在派生类的对象中无法访问，在派生类的派生类中视继承方式有可能为私有成员或者保护成员。<br>4）<em>共有成员</em>派生类、派生类的对象中都可访问，继续派生可能成为私有、共有、保护成员。<br>在派生类的访问中，有两个问题需要解决：一个是唯一标识符的问题，另一个是成员本身属性的问题，严格来将就是可见性问题（即上面四点？）。若成员没办法唯一标识，就会产生二义性。</p>
<h3 id="作用域分辨符"><a href="#作用域分辨符" class="headerlink" title="作用域分辨符"></a>作用域分辨符</h3><p>作用域分辨符即我们常见的“::”，用于限定要访问的成员所在类的名称。</p>
<blockquote>
<p>类名::成员名                    //对数据成员<br>类名::成员名(参数表)        //对函数成员</p>
</blockquote>
<p>在类的派生层次的结构中，派生类新增成员和基类都具有类作用域。派生类为内层，基类为外层。在之前学到的作用域的范围中可知，内层若和外层有同名的函数或者同名的数据，则在内层中外层的同名成员是不可见的，这种现象就是隐藏规则。<br>则可知，若派生类的新增成员中有和基类相同的成员，则通过派生类对象指针-&gt;成员名或者对象名.成员名使用的是派生类中新增成员。若要使用基类的成员则要通过基类名和作用域分辨符来标示成员。同样的，如果派生类多继承了多个基类（基类中没有继承关系），也要使用基类名和作用域分辨符来唯一标识是哪个基类的中的成员。<br>来个🌰</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base1&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int var;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void fun()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout&lt;&lt;&quot;Base1&quot;&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base2&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int var;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void fun()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout&lt;&lt;&quot;Base2&quot;&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Derived:public Base2,public Base1&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int var;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void fun()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout&lt;&lt;&quot;Derived&quot;&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derived d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derived *pd&#x3D;&amp;d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    d.var&#x3D;1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d.fun();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    d.Base1::fun();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    pd-&gt;Base2::var&#x3D;2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pd-&gt;Base2::fun();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>Derived<br>Base1<br>Base2</p>
</blockquote>
<p>特别注意使用时的语法规则，对象指针-&gt;基类名::成员；对象名::基类名::成员</p>
<p>若在派生类中没有新增同名的成员，则通过不加基类名的成员引用就会报错，因为产生了二义性，这个很好理解，解决则要加基类名。另一个解决方式就时用using关键字加以澄清：</p>
<blockquote>
<p>class Derived:public Base1,public Base2{<br>public:<br>    using Base1::var;<br>    using Base2::fun();<br>}</p>
</blockquote>
<p>这样在使用d.var;d.fun();时就不会产生二义性。using的一般功能就是将一个作用域中的名字引入到另一个作用域中，它还有个很有用的用法就是将using用于基类中的函数名，这样在派生类中定义了同名但是参数表不同的函数时，基类的函数不会被隐藏。若无using，即使基类和派生类中的函数参数表不同也是会隐藏基类中的函数的。</p>
<blockquote>
<p>class Derived2:public Base1{<br>public:<br>    using Base1::fun;<br>    void fun(int i){…}<br>}</p>
</blockquote>
<p>这时使用Derived2对象时，调用没有参数的函数就时是调用的基类，调用有一个int 参数时的函数就是调用的派生类中的函数。</p>
<p>上面讨论的是基类没有继承关系的派生类。若有继承关系则：<br>若有三层继承关系，我们称最最基层的类为间接继承的基类，中间层的为直接基类，剩下一层为派生类。若派生类的部分或全部直接基类是从另一个童工的基类派生而来的，在这些直接基类中就有相同的从间接基类继承而来的成员，因此派生类中也会产生同名现象，对这类的同名成员的标识则要用直接基类的基类名来进行限定。<br>举个🌰，Base0为间接基类，Base1、Base2继承Base0，为直接基类。Derived为派生类，同时多继承Base2、Base3。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace  std;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base0&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int var0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void fun0()&#123;cout&lt;&lt;&quot;Member of Base0&quot;&lt;&lt;endl;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base1:public Base0&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int var1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base2:public Base0&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int var2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Derived:public Base1,public Base2&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int var;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void fun()&#123;cout&lt;&lt;&quot;Member of Derived&quot;&lt;&lt;endl;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derived d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d.Base1::var0&#x3D;2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d.Base1::fun0();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d.Base2::var0&#x3D;3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d.Base2::fun0();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base1 b1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    b1.Base0::fun0();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>Member of Base0<br>Member of Base0<br>Member of Base0</p>
</blockquote>
<p>注意派生类只能通过直接基类的作用域来使用间接基类的成员，用间接基类的作用域会报错。</p>
<p>在上面这种情况下，派生类Derived中存在两个副本Base0的副本，这无疑会增加存储空间的开销，因此我们引入虚基类。需要注意的是，var0被在Derived中有两个副本，但是fun0()只有一个副本，但是调用函数的时候还是要用Base1，Base2来加以限定，因为在执行非静态成员函数调用时要将指向该类的一个对象的指针作为隐含的参数传递给被调用函数来初始化this指针，因此在调用fun0()函数时，需要使用Base1，Base2加以限定，这样才能明确针对哪个Base0对象调用。（在Derived中有Base1中的Base0，和Base2中的Base0两个Base0副本）</p>
<h3 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h3><p>在上述情况下，在派生类中会有多个同名的副本，同一个函数会有多个映射，这样的情况下的解决方法时使用虚基类：将共同继承的基类设置为虚基类，这时候，在派生类中就只有一个同名数据成员的副本，同一个函数也就只有一个映射。</p>
<blockquote>
<p>class 派生类名:virtual 继承方式 基类名</p>
</blockquote>
<p>虚基类的🌰，关系和内容同上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace  std;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base0&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int var0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void fun0()&#123;cout&lt;&lt;&quot;Member of Base0&quot;&lt;&lt;endl;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base1:virtual public Base0&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int var1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base2:virtual public Base0&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int var2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Derived:public Base1,public Base2&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int var;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void fun()&#123;cout&lt;&lt;&quot;Member of Derived&quot;&lt;&lt;endl;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derived d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d.var0&#x3D;2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d.fun0();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>Member of Base0</p>
</blockquote>
<p>通过上面的例子我们只是在间接继承的类和直接之间的继承关系中加入了virtual，在派生类的对象就能直接使用对象名.成员了。<br>这两个例子，前者可以容纳更多的数据，而后者的存储更加简洁，在具体使用时不能一概而论，要视具体情况来选择。</p>
<h3 id="虚基类及其派生类构造函数"><a href="#虚基类及其派生类构造函数" class="headerlink" title="虚基类及其派生类构造函数"></a>虚基类及其派生类构造函数</h3><p>在上面的两个🌰中，如果有构造函数，那么情况就要变成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace  std;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base0&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int var0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base0(int var):var0(var)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void fun0()&#123;cout&lt;&lt;&quot;Member of Base0&quot;&lt;&lt;endl;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base1:virtual public Base0&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base1(int var):Base0(var)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int var1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Base2:virtual public Base0&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Base2(int var):Base0(var)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int var2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Derived:public Base1,public Base2&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int var;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derived(int var):Base0(var),Base1(var),Base2(var)&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void fun()&#123;cout&lt;&lt;&quot;Member of Derived&quot;&lt;&lt;endl;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Derived d(1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d.var0&#x3D;2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d.fun0();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>可以在这个例子中看到，Derivered类最远派生类中对Base0、Base1、Base2进行了三次初始化，那Base0中的var0会不会被初始化三次呢？这个在C++系统中有自行解决的办法：建立Derived类时，如果这个对象中含有从虚基类继承而来的成员，则虚基类中的成员是由最远派生类的构造函数通过调用基类的构造函数进行初始话的，直接基类中的构造函数会被系统忽略掉。</p>
<blockquote>
<p>构造一个类的对象的一般顺序：<br>1）该类有直接或间接继承的虚基类，则会首先调用虚基类的构造函数<br>2）如果该类有其它继承的基了，则会按照其继承的顺序调用它们的构造函数（但在执行过程中不会再执行它们的虚基类的构造函数）<br>3）按照在类定义中出现的顺序，对派生类中新增成员对象进行初始化，初始化顺序是在类中声明的顺序。对初始化列表中的基本数据类型进行初始化。<br>4）执行构造函数的函数体。</p>
</blockquote>
<h2 id="程序实例——用高斯消去法"><a href="#程序实例——用高斯消去法" class="headerlink" title="程序实例——用高斯消去法"></a>程序实例——用高斯消去法</h2><p>矩阵分成A部分的方形的系数矩阵，和B部分的（A，b）增广矩阵。<br>关键是全选主元高斯消去法的算法，大致描述如下：<br>主要分两步：<br><em>第一步是消去过程</em>：<br>1、A部分从左上角开始，选取最大的元素，通过该元素的行列交换，把该最大元素放在最左上角。<br>2、这一行的除了它本身的剩下的所有元素除以该元素，包括增广部分<br>3、将A矩阵左上部分缩小一圈，剩下的部分用本元素减去该行的第一个和该列的第一个的乘积。<br>上述操作循环进行，直到A变成一个2<em>2的矩阵，即用一个循环k阔起来，k的范围是0～n-2<br>*第二步是回代入</em>：<br>从下往上<br>Xn-1=bn-1/an-1,n-1<br>Xn-i=bn-i-之前算的x的值*系数</p>
<blockquote>
<p>Matrix.hpp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef Matrix_hpp</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define Matrix_hpp</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">class Matrix&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">private:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    double *elements;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Matrix(int s&#x3D;2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ~Matrix();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void setMatrix(const double* value);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    void printMatrix() const;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int getSize() const&#123;return size;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    double &amp;element(int i,int j)&#123;return elements[i*size+j];&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    double element(int i,int j)const&#123;return elements[i*size+j];&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#endif &#x2F;* Matrix_hpp *&#x2F;</span></pre></td></tr></table></figure>
<blockquote>
<p>Matrix.cpp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;Matrix.hpp&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Matrix::Matrix(int s):size(s)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    elements&#x3D;new double(size*size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Matrix::~Matrix()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    delete []elements;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">void Matrix::setMatrix(const double *value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (int i&#x3D;0; i&lt;size*size; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        elements[i]&#x3D;value[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">void Matrix::printMatrix()const&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout&lt;&lt;&quot;The Matrix is:&quot;&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (int i&#x3D;0; i&lt;size; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        for (int j&#x3D;0; j&lt;size; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cout&lt;&lt;element(i, j)&lt;&lt;&quot; &quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>LinearEqu.hpp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;Matrix.hpp&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Matrix::Matrix(int s):size(s)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    elements&#x3D;new double(size*size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Matrix::~Matrix()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    delete []elements;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">void Matrix::setMatrix(const double *value)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (int i&#x3D;0; i&lt;size*size; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        elements[i]&#x3D;value[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">void Matrix::printMatrix()const&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout&lt;&lt;&quot;The Matrix is:&quot;&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (int i&#x3D;0; i&lt;size; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        for (int j&#x3D;0; j&lt;size; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cout&lt;&lt;element(i, j)&lt;&lt;&quot; &quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>LinearEqu.cpp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;LinearEqu.hpp&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;cmath&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line">LinearEqu::LinearEqu(int size):Matrix(size)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sums&#x3D;new double(size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    solution&#x3D; new double(size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">LinearEqu::~LinearEqu()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    delete []sums;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    delete []solution;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">void LinearEqu::setLinearEqu(const double *a,const double *b)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    setMatrix(a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (int i&#x3D;0; i&lt;getSize(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sums[i]&#x3D;b[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">void LinearEqu::printLinearEqu()const&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout&lt;&lt;&quot;The Line eqution is:&quot;&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (int i&#x3D;0; i&lt;getSize(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        for (int j&#x3D;0; j&lt;getSize(); j++)  </span></pre></td></tr><tr><td class="code"><pre><span class="line">            cout&lt;&lt;element(i, j)&lt;&lt;&quot; &quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cout&lt;&lt;&quot;     &quot;&lt;&lt;sums[i]&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">void LinearEqu::printSolution()const&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout&lt;&lt;&quot;The Result is :&quot;&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (int i&#x3D;0; i&lt;getSize(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout&lt;&lt;&quot;x[&quot;&lt;&lt;i&lt;&lt;&quot;]&#x3D;&quot;&lt;&lt;solution[i]&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">inline void swap(double &amp;v1,double &amp;v2)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    double temp&#x3D;v1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v1&#x3D;v2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v2&#x3D;temp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">bool LinearEqu::solve()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int *js&#x3D;new int(getSize());                     &#x2F;&#x2F;存储主元素所在列号的数组</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (int k&#x3D;0; k&lt;getSize()-1; k++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        int is;                                     &#x2F;&#x2F;主元素所在行号</span></pre></td></tr><tr><td class="code"><pre><span class="line">        double max&#x3D;0;                               &#x2F;&#x2F;所有元素的最大值</span></pre></td></tr><tr><td class="code"><pre><span class="line">        for (int i&#x3D;k; i&lt;getSize(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            for (int j&#x3D;k; j&lt;getSize(); j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                double t&#x3D;fabs(element(i, j));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                if (t&gt;max) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    max&#x3D;t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    js[k]&#x3D;j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    is&#x3D;i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if(max&#x3D;&#x3D;0)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            delete []js;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return false;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        else&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if(js[k]!&#x3D;k)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                for(int i &#x3D; 0;i&lt;getSize();i++)              &#x2F;&#x2F;列交换</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    swap(element(i,k), element(i, js[k]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if(is!&#x3D;k)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                for (int j&#x3D;k; j&lt;getSize(); j++)           &#x2F;&#x2F;行交换</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    swap(element(k, j), element(is, j));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                swap(sums[k], sums[is]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        double major&#x3D;element(k, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        for (int j&#x3D;k+1; j&lt;getSize(); j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            element(k, j)&#x2F;&#x3D;major;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sums[k]&#x2F;&#x3D;major;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        for (int i&#x3D;k+1; i&lt;getSize(); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            for( int j&#x3D;k+1;j&lt;getSize();j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                element(i, j)-&#x3D;element(i, k)*element(k, j);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            sums[i]-&#x3D;element(i, k)*sums[k];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;判断剩下的一个元素是否等于零</span></pre></td></tr><tr><td class="code"><pre><span class="line">    double d&#x3D;element(getSize()-1, getSize()-1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if (fabs(d)&lt;1e-15) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        delete []js;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return false;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;回带过程</span></pre></td></tr><tr><td class="code"><pre><span class="line">    solution[getSize()-1]&#x3D;sums[getSize()-1]&#x2F;d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (int i&#x3D;getSize()-2; i&gt;&#x3D;0; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        double t&#x3D;0.0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        for (int j&#x3D;i+1; j&lt;&#x3D;getSize()-1; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            t+&#x3D;element(i, j)*solution[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        solution[i]&#x3D;sums[i]-t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    js[getSize()-1]&#x3D;getSize()-1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (int k&#x3D;getSize()-1; k&gt;&#x3D;0; k--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if(js[k]!&#x3D;k)swap(solution[k],solution[js[k]] );</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    delete js;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return true;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>main.cpp</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &quot;Matrix.hpp&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &quot;LinearEqu.hpp&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace  std;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    double a[]&#x3D;&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        0.2368,0.2471,0.2568,1.2671,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        0.1968,0.2071,1.2168,0.2271,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        0.1581,1.1675,0.1768,0.1871,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        1.1161,0.1254,0.1397,0.1490</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    double b[]&#x3D;&#123;1.8471,1.7471,1.6471,1.5471&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LinearEqu equ(4);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    equ.setLinearEqu(a, b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    equ.printLinearEqu();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if(equ.solve())</span></pre></td></tr><tr><td class="code"><pre><span class="line">        equ.printSolution();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    else</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout&lt;&lt;&quot;Fail&quot;&lt;&lt;endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>The Line eqution is:<br>0.2368 0.2471 0.2568 1.2671      1.8471<br>0.1968 0.2071 1.2168 0.2271      1.7471<br>0.1581 1.1675 0.1768 0.1871      1.6471<br>1.1161 0.1254 0.1397 0.149      1.5471<br>The Result is :<br>x[0]=1.04058<br>x[1]=0.987051<br>x[2]=0.93504<br>x[3]=0.881282</p>
</blockquote>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-C plus plus</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构关键词索引（五）</title>
    <url>/2019/12/06/Key-Words-in-Date-Structure5/</url>
    <content><![CDATA[<h1 id="第五章-二叉树"><a href="#第五章-二叉树" class="headerlink" title="第五章 二叉树"></a>第五章 二叉树</h1><a id="more"></a>
<h3 id="线性结构（linear-structure）P110"><a href="#线性结构（linear-structure）P110" class="headerlink" title="线性结构（linear structure）P110"></a>线性结构（linear structure）<em>P110</em></h3><p>元素之间存在一个自然的线性次序，故它们都属于所谓的线性结构。</p>
<h3 id="半线性结构（semi-linear-structure）"><a href="#半线性结构（semi-linear-structure）" class="headerlink" title="半线性结构（semi-linear structure）"></a>半线性结构（semi-linear structure）</h3><p>树则不然，元素之间并不存在天然的直接后继或直接前驱关系，只要附加某种约束（比如遍历），也可以在树中的元素之间确定某种线性次序，因此属于半线性结构。</p>
<h3 id="顶点（vertex）、边（edge）、根（root）、节点（node）、有根树（rooted-tree）P110"><a href="#顶点（vertex）、边（edge）、根（root）、节点（node）、有根树（rooted-tree）P110" class="headerlink" title="顶点（vertex）、边（edge）、根（root）、节点（node）、有根树（rooted tree）P110"></a>顶点（vertex）、边（edge）、根（root）、节点（node）、有根树（rooted tree）<em>P110</em></h3><p>从图论的角度看，树等价于连通无环图，因此与图一样，树也由一组顶点、以及连接与其间的若干条边组成，在计算机科学中，还会制定某一特定顶点并称之为根。在指定根节点之后，我们也称之为有根树。从程序的角度看，我们更多地将顶点称作节点。</p>
<h3 id="祖先（ancestor）、后代（descendant）、真祖先（properancestor）、真后代（proper-descendant）P111"><a href="#祖先（ancestor）、后代（descendant）、真祖先（properancestor）、真后代（proper-descendant）P111" class="headerlink" title="祖先（ancestor）、后代（descendant）、真祖先（properancestor）、真后代（proper descendant）P111"></a>祖先（ancestor）、后代（descendant）、真祖先（properancestor）、真后代（proper descendant）<em>P111</em></h3><p>任一节点v在通往树根沿途径所经过的每一个节点都称为他的祖先，v是它们的后代。特别指出的是，v的祖先/后代包括其本身，而v本身以外的祖先/后代称作真祖先/真后代。</p>
<h3 id="父亲（parent）、孩子（child）P111"><a href="#父亲（parent）、孩子（child）P111" class="headerlink" title="父亲（parent）、孩子（child）P111"></a>父亲（parent）、孩子（child）<em>P111</em></h3><p>节点v历代祖先的层次，自下而上以1为单位逐层递减；在每一层上，v的祖先至多一个。特别地，若节点u是v的祖先且恰好比v高出一层，则称u是v的父亲，v是u的孩子。</p>
<h3 id="度数-度（degree）、叶节点（leaf）、内部节点（internal-node）P111"><a href="#度数-度（degree）、叶节点（leaf）、内部节点（internal-node）P111" class="headerlink" title="度数/度（degree）、叶节点（leaf）、内部节点（internal node）P111"></a>度数/度（degree）、叶节点（leaf）、内部节点（internal node）<em>P111</em></h3><p>任一节点v的孩子总数，称作其度数或度。无孩子的节点称作叶节点，包括根在内的其余节点皆为内部节点。</p>
<h3 id="子树（subtree）P111"><a href="#子树（subtree）P111" class="headerlink" title="子树（subtree）P111"></a>子树（subtree）<em>P111</em></h3><p>任一节点v的所有后代及其之间的联边称作子树，记作subtree（v），我们往往不区分节点（v）以及以之为根的子树subtree（v）。</p>
<h3 id="高度（height）P111"><a href="#高度（height）P111" class="headerlink" title="高度（height）P111"></a>高度（height）<em>P111</em></h3><p>树T中所有节点深度的最大值称作该树的高度。</p>
<h3 id="二叉树（binary-tree）P111"><a href="#二叉树（binary-tree）P111" class="headerlink" title="二叉树（binary tree）P111"></a>二叉树（binary tree）<em>P111</em></h3><p>二叉树中每个节点的度数均不超过2。</p>
<h3 id="有序二叉树（ordered-binary-tree）P111"><a href="#有序二叉树（ordered-binary-tree）P111" class="headerlink" title="有序二叉树（ordered binary tree）P111"></a>有序二叉树（ordered binary tree）<em>P111</em></h3><p>在二叉树中，同一父节点的孩子都可以以左、右相互区分——此时，亦称作有序二叉树。</p>
<h3 id="真二叉树（proper-binary-tree）P111"><a href="#真二叉树（proper-binary-tree）P111" class="headerlink" title="真二叉树（proper binary tree）P111"></a>真二叉树（proper binary tree）<em>P111</em></h3><p>不含一度节点的二叉树称作真二叉树。</p>
<h3 id="多叉树（k-ary-tree）P112"><a href="#多叉树（k-ary-tree）P112" class="headerlink" title="多叉树（k-ary tree）P112"></a>多叉树（k-ary tree）<em>P112</em></h3><p>一般地，树中各节点的孩子数目并不确定，每个节点的孩子均不超过k个的有根树，称作k叉树。</p>
<h3 id="有序树（odered-tree）P113"><a href="#有序树（odered-tree）P113" class="headerlink" title="有序树（odered tree）P113"></a>有序树（odered tree）<em>P113</em></h3><p>在树中，同一父亲节点的孩子都可以相互按次序区分——此时，亦称作有序树。</p>
<h3 id="编码（encoding）、解码（decoding）P114"><a href="#编码（encoding）、解码（decoding）P114" class="headerlink" title="编码（encoding）、解码（decoding）P114"></a>编码（encoding）、解码（decoding）<em>P114</em></h3><p>在加载到信道上之前，信息被转换成为二进制形式的过程称作编码，反之，经信道抵达目标后再由二进制编码恢复原始信息的过程叫做解码。</p>
<h3 id="前缀无歧义编码（prefix-free-code）P115"><a href="#前缀无歧义编码（prefix-free-code）P115" class="headerlink" title="前缀无歧义编码（prefix-free code）P115"></a>前缀无歧义编码（prefix-free code）<em>P115</em></h3><p>只要各字符的编码串互不为前缀，则即便出现无法解码的错误，也绝不会出现歧义。</p>
<h3 id="根通路串（root-path-string）P116"><a href="#根通路串（root-path-string）P116" class="headerlink" title="根通路串（root path string）P116"></a>根通路串（root path string）<em>P116</em></h3><p>任一编码方案都可描述为一颗二叉树：从根节点出发，每次向左（右）都对应一个0（1）比特位，由从根节点到每个节点的唯一通路，可以为各节点v赋予一个互异的二进制串，称作根通路串，记作rps（v），rps（v）= depth（v），就是v 的深度。</p>
<h3 id="二叉树节点（binary-tree-node）P117"><a href="#二叉树节点（binary-tree-node）P117" class="headerlink" title="二叉树节点（binary tree node）P117"></a>二叉树节点（binary tree node）<em>P117</em></h3><p>作为图的特殊形式，二叉树的基本组成单位是节点与边；作为数据结构，其基本的组成实体是二叉树节点，而边则对应于节点之间的相互引用。</p>
<h3 id="广度优先遍历、层序遍历（level-order-traversal）P133"><a href="#广度优先遍历、层序遍历（level-order-traversal）P133" class="headerlink" title="广度优先遍历、层序遍历（level-order traversal）P133"></a>广度优先遍历、层序遍历（level-order traversal）<em>P133</em></h3><p>确定节点访问次序的原则可以概括为“先上后下，先左后右”，先访问根节点，再访问根节点的左孩子、右孩子，然后是左孩子的左孩子，左孩子的右孩子，右孩子的左孩子，右孩子的右孩子……以此类推。</p>
<h3 id="完全二叉树（complete-binary-tree）P135"><a href="#完全二叉树（complete-binary-tree）P135" class="headerlink" title="完全二叉树（complete binary tree）P135"></a>完全二叉树（complete binary tree）<em>P135</em></h3><p>在层序遍历算法的每次迭代中，必有一个节点出队（而且不再入队）故累计恰好迭代n次，然而每次迭代中入队节点的数目并不确定。若在对某棵二叉树的层序遍历中，前「n/2」次迭代中都有左孩子入队，且前「n/2」-1次迭代中都有右孩子入队，则称之为完全二叉树。其一般性的宏观拓扑结构特征：叶节点只能出现在最底部的两层，且最底层叶节点均处于次底层叶节点的左侧。</p>
<h3 id="满二叉树（full-binary-tree）P135"><a href="#满二叉树（full-binary-tree）P135" class="headerlink" title="满二叉树（full binary tree）P135"></a>满二叉树（full binary tree）<em>P135</em></h3><p>完全二叉树的一种特列是，所有叶节点同处于最底层（非底层节点均为内部节点）。根据数学归纳法，每一层的节点数都应达到饱和，故将其称为满二叉树。</p>
<h3 id="Huffman编码树（Huffman-coding-tree）P143"><a href="#Huffman编码树（Huffman-coding-tree）P143" class="headerlink" title="Huffman编码树（Huffman coding tree）P143"></a>Huffman编码树（Huffman coding tree）<em>P143</em></h3><p>首先，对应于∑中的每一个字符，分别建立一个单个节点的树，其权重取作该字符的频率，这｜∑｜棵树构成了一个森林。接下来在ξ中选取权重最小的两棵树，创建一个新的节点，作为其左右子树，如此将它作为一棵新的更高的树，其权重为左右叶节点的和。这个新的树等效地视作一个字符，称作超字符。<br>这一选取、合并的过程反复迭代进行，每一次迭代ξ中的树就减少一棵，当最终ξ仅包含一棵树的时候，就形成了一棵最优带权编码树，构造过程随即完成。<br>以上构造过程被称为Huffman编码算法，由其生成的编码树称作Huffman编码树。需强调的是，Huffman编码树只是最优带权编码树中的一棵。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构》关键词索引（四）</title>
    <url>/2019/12/06/Key-Words-in-Date-Structure4/</url>
    <content><![CDATA[<h1 id="第四章栈与队列"><a href="#第四章栈与队列" class="headerlink" title="第四章栈与队列"></a>第四章栈与队列</h1><a id="more"></a>
<h3 id="栈（stack）P86"><a href="#栈（stack）P86" class="headerlink" title="栈（stack）P86"></a>栈（stack）<em>P86</em></h3><p>栈是存放数据对象的一种特殊容器，其中的数据元素按线性的逻辑次序排列，故可以定义首、末元素。栈结构支持插入和删除操作，但仅限于某特定的一段，禁止操作的一端被称作盲端。</p>
<h3 id="栈顶（stack-top）、栈底（stack-bottom）P87"><a href="#栈顶（stack-top）、栈底（stack-bottom）P87" class="headerlink" title="栈顶（stack top）、栈底（stack bottom）P87"></a>栈顶（stack top）、栈底（stack bottom）<em>P87</em></h3><p>栈中可操作的一端称为栈顶，而另一端无法直接操作的盲端称为栈底。</p>
<h3 id="入栈（push）、出栈（pop）"><a href="#入栈（push）、出栈（pop）" class="headerlink" title="入栈（push）、出栈（pop）"></a>入栈（push）、出栈（pop）</h3><p>栈的插入和删除分别称为入栈和出栈。</p>
<h3 id="后进先出（last-in-first-out，LIFO）"><a href="#后进先出（last-in-first-out，LIFO）" class="headerlink" title="后进先出（last-in-first-out，LIFO）"></a>后进先出（last-in-first-out，LIFO）</h3><p>由于栈位置的约定和限制可知，栈中的元素必然遵循“后进先出”的规律，从栈的整个生命周期来看，最先进入栈的元素会最后出栈，最后入栈的元素会最先出栈。</p>
<h3 id="点用栈（call-stack）、执行栈（execution-stack）P89"><a href="#点用栈（call-stack）、执行栈（execution-stack）P89" class="headerlink" title="点用栈（call stack）、执行栈（execution stack）P89"></a>点用栈（call stack）、执行栈（execution stack）<em>P89</em></h3><p>在大多数操作系统中，每一个运行中的二进制程序都配有一个调用栈或执行栈，借助点用栈可以跟踪属于同一程序的所有函数，记录它们之间的相互调用关系，并保证在每一调用实例执行完毕之后，可以准确地返回。</p>
<h3 id="帧（frame）、返回地址（return-address）P89"><a href="#帧（frame）、返回地址（return-address）P89" class="headerlink" title="帧（frame）、返回地址（return address）P89"></a>帧（frame）、返回地址（return address）<em>P89</em></h3><p>调用栈的基本单位是帧，每次调用函数时，都会相应地创建一帧，记录该函数实例在二进制程序中的返回地址，以及局部变量、传人参数等，并将该帧压入调用栈。</p>
<h3 id="活跃函数实例（active-function-instance）P89"><a href="#活跃函数实例（active-function-instance）P89" class="headerlink" title="活跃函数实例（active function instance）P89"></a>活跃函数实例（active function instance）<em>P89</em></h3><p>在任一时刻，调用栈中的各帧，依次对应于那些尚未返回的调用实例，亦即当时的活跃函数实例。</p>
<h3 id="逆波兰表达式（reverse-Polish-notation-RPN）P96"><a href="#逆波兰表达式（reverse-Polish-notation-RPN）P96" class="headerlink" title="逆波兰表达式（reverse Polish notation,RPN）P96"></a>逆波兰表达式（reverse Polish notation,RPN）<em>P96</em></h3><p>逆波兰表达式是数学表达式的一种，其语法规则可概括为：操作符紧邻于对应的（最后一个）操作数之后。</p>
<h3 id="后缀表达式（postfix）、中缀表达式（infix）P97"><a href="#后缀表达式（postfix）、中缀表达式（infix）P97" class="headerlink" title="后缀表达式（postfix）、中缀表达式（infix）P97"></a>后缀表达式（postfix）、中缀表达式（infix）<em>P97</em></h3><p>RPN亦称作后缀表达式，原表达式亦称作中缀表达式。</p>
<h3 id="剪枝（pruning）P99"><a href="#剪枝（pruning）P99" class="headerlink" title="剪枝（pruning）P99"></a>剪枝（pruning）<em>P99</em></h3><p>基于对应用问题的深刻理解，利用问题本身具有的某些规律尽可能多、尽可能早地排除搜索空间中的候选解。其中一种重要的技巧就是，根据候选解的某些局部特征，以候选解子集为单位批量地排除。搜索空间多呈树状结构，而被排除的候选解往往隶属于同一分枝，故这一技巧也可以形象地称作剪枝。</p>
<h3 id="试探（probing）P99"><a href="#试探（probing）P99" class="headerlink" title="试探（probing）P99"></a>试探（probing）<em>P99</em></h3><p>剪枝对应的算法多呈现为如下模式：从零开始，尝试逐步增加候选解的长度，这一过程是在成批地考察具有特定前缀的所有候选解，这种从长度是上逐步向目标靠近的尝试，称作试探。</p>
<h3 id="回溯（backtracking）P99"><a href="#回溯（backtracking）P99" class="headerlink" title="回溯（backtracking）P99"></a>回溯（backtracking）<em>P99</em></h3><p>作为解的局部特征，特征前缀在试探的过程中一旦被发现与目标解不合，则收缩到前一步的长度，然后继续下一可能的组合。特征前缀长度缩减的这类操作，称作回溯。</p>
<h3 id="队列（queue）、队头（front）、队尾（rear）P105"><a href="#队列（queue）、队头（front）、队尾（rear）P105" class="headerlink" title="队列（queue）、队头（front）、队尾（rear）P105"></a>队列（queue）、队头（front）、队尾（rear）<em>P105</em></h3><p>队列也是存放数据对象的一种容器，其中的数据对象也按线性的逻辑次序排列。队列结构同样支持对象的插入和删除，但两种操作的范围分别被限制于队列的两端——若约定新对象只能从某一端插入其中，则只能从另一端删除已有的元素。允许取出元素的一端作队头，而允许插入元素的另一端称作队尾。</p>
<h3 id="入队（enqueue）、出队（dequeue）P105"><a href="#入队（enqueue）、出队（dequeue）P105" class="headerlink" title="入队（enqueue）、出队（dequeue）P105"></a>入队（enqueue）、出队（dequeue）<em>P105</em></h3><p>元素的插入与删除也是修改队列结构的两种主要方式，站在被操作对象的角度，分别称作入队、出队。</p>
<h3 id="先进先出（first-in-first-out，FIFO）P105"><a href="#先进先出（first-in-first-out，FIFO）P105" class="headerlink" title="先进先出（first-in-first-out，FIFO）P105"></a>先进先出（first-in-first-out，FIFO）<em>P105</em></h3><p>由队列的约定和限制不难看出，与栈结构相反，队列中各对象的操作次序遵循先进先出（first-in-first-out）的规律，更早（晚）出队的元素应该为更早（晚）入队者，反之，更早（晚）入队者应更早（晚）出队。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构》关键词索引（三）</title>
    <url>/2019/12/04/Key-Words-in-Data-Structure3/</url>
    <content><![CDATA[<h1 id="第三章列表"><a href="#第三章列表" class="headerlink" title="第三章列表"></a>第三章列表</h1><a id="more"></a>
<h3 id="列表（list）、位置（position）、寻位置访问（call-by-position）、链接（link）、寻链接访问（call-by-link）P66-列表的列表中的元素之间的逻辑结构是相邻的，但是元素之间的物理存储位置却不一定是相邻的，为了保证能够对列表中的元素进行访问，前驱和后继之间应该保持一种一种索引的关系，这种索引的关系就被抽象为位置，所以列表的访问方式称为寻位置访问，或者说可以把这种索引关系抽象为链接，那么那么列表的访问方式也可以被称作寻群链接访问。"><a href="#列表（list）、位置（position）、寻位置访问（call-by-position）、链接（link）、寻链接访问（call-by-link）P66-列表的列表中的元素之间的逻辑结构是相邻的，但是元素之间的物理存储位置却不一定是相邻的，为了保证能够对列表中的元素进行访问，前驱和后继之间应该保持一种一种索引的关系，这种索引的关系就被抽象为位置，所以列表的访问方式称为寻位置访问，或者说可以把这种索引关系抽象为链接，那么那么列表的访问方式也可以被称作寻群链接访问。" class="headerlink" title="列表（list）、位置（position）、寻位置访问（call-by-position）、链接（link）、寻链接访问（call-by-link）P66 列表的列表中的元素之间的逻辑结构是相邻的，但是元素之间的物理存储位置却不一定是相邻的，为了保证能够对列表中的元素进行访问，前驱和后继之间应该保持一种一种索引的关系，这种索引的关系就被抽象为位置，所以列表的访问方式称为寻位置访问，或者说可以把这种索引关系抽象为链接，那么那么列表的访问方式也可以被称作寻群链接访问。"></a>列表（list）、位置（position）、寻位置访问（call-by-position）、链接（link）、寻链接访问（call-by-link）<em>P66</em> 列表的列表中的元素之间的逻辑结构是相邻的，但是元素之间的物理存储位置却不一定是相邻的，为了保证能够对列表中的元素进行访问，前驱和后继之间应该保持一种一种索引的关系，这种索引的关系就被抽象为位置，所以列表的访问方式称为寻位置访问，或者说可以把这种索引关系抽象为链接，那么那么列表的访问方式也可以被称作寻群链接访问。</h3><h3 id="列表（list）P66"><a href="#列表（list）P66" class="headerlink" title="列表（list）P66"></a>列表（list）<em>P66</em></h3><p>列表的元素之间的逻辑上，虽然要求具有连续性，但是其物理存储地址上并没有要求有连续性，此所谓动态存储策略。</p>
<h3 id="链表（linked-list）P66"><a href="#链表（linked-list）P66" class="headerlink" title="链表（linked list）P66"></a>链表（linked list）<em>P66</em></h3><p>链表就是一种典型的动态存储的结构，在动态存储结构中，数据被分为一个个节点，节点之间通过指针相互索引和访问，为了引入新的节点或者删除节点，只需要在局部调整少量几点之间的指针就可以了，相比起来，采用动态存储策略可以大大减少动态操作的成本。</p>
<h3 id="列表（list）P67"><a href="#列表（list）P67" class="headerlink" title="列表（list）P67"></a>列表（list）<em>P67</em></h3><p>列表是一个集合，在这个集合中所有元素之间都具有一定的线性逻辑次序。列表结构是链表结构的一般化推广，其中的元素被称为节点，节点通过链接和通过链接和位置来指代。在元素中也可以定以前缺后继也直接前去直接后继，对于任意元素也定义有相对应的前缀后缀等子集。</p>
<h3 id="头节点（header）、尾节点（trailer）、首节点（first-node）、末节点（last-node）、哨兵节点（sentinel-node）P71"><a href="#头节点（header）、尾节点（trailer）、首节点（first-node）、末节点（last-node）、哨兵节点（sentinel-node）P71" class="headerlink" title="头节点（header）、尾节点（trailer）、首节点（first node）、末节点（last node）、哨兵节点（sentinel node）P71"></a>头节点（header）、尾节点（trailer）、首节点（first node）、末节点（last node）、哨兵节点（sentinel node）<em>P71</em></h3><p>list对象内部组成中，头节点、尾节点始终存在，但对外并不可见。对外部可见的数据节点如果存在，则其中第一个和最后一个节点分别称为首节点和末节点。头节点紧邻于首节点之前，尾节点紧邻于末节点之后，这类经封装后对外部不可见的节点称为哨兵节点。</p>
<h3 id="有序列表（sorted-list）P77"><a href="#有序列表（sorted-list）P77" class="headerlink" title="有序列表（sorted list）P77"></a>有序列表（sorted list）<em>P77</em></h3><p>若列表中所有节点的逻辑次序和其和其大小次序完全一致，则被称为有序列表。</p>
<h3 id="插入排序（insertionsort）P79"><a href="#插入排序（insertionsort）P79" class="headerlink" title="插入排序（insertionsort）P79"></a>插入排序（insertionsort）<em>P79</em></h3><p>插入排序适用于任何序列结构，他的算法的大致思路可以概括为，始终将序列切分为有序的前缀和无序的后缀，将后缀中的首元素，放入有序的前缀中。插入排序就跟打牌一样，你先摸一张起来，就是牌堆里面的无序的牌，但是手里的牌是有序的，你每摸出一张无序的牌，就是相当于从它的后缀里面取出一个元素出来，你手里的牌就是前置里面有序的排，把每张牌都插入到你那个手中牌的正确的位置中，这就是插入排序。</p>
<h3 id="选择排序（selectionsort）P80"><a href="#选择排序（selectionsort）P80" class="headerlink" title="选择排序（selectionsort）P80"></a>选择排序（selectionsort）<em>P80</em></h3><p>选择排序也适用于任何序列结构，他的算法的大致思路是也将训练分为无序的前缀和有序的后缀，在无序的前缀中选出最大的元素，放入后缀的开头。选择排序相当于相当于串手链，就是你手里面有一堆珠子放在一个盘子里面，然后你要用从大到小的顺序把那个珠子给串起来，你就在那一堆没有排序的前缀的中间选出一个最大的元素，然后放在那个绳子上面，在那个里面再选出最大的元素，然后再把它放在有序的后缀中，然后再选出前中最大的元素，再放入那个后缀中对应的位置。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>毛中特第十章（五）</title>
    <url>/2019/12/03/%E6%AF%9B%E4%B8%AD%E7%89%B9%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%885%EF%BC%89/</url>
    <content><![CDATA[<h1 id="“五位一体”总布局之生态文明"><a href="#“五位一体”总布局之生态文明" class="headerlink" title="“五位一体”总布局之生态文明"></a>“五位一体”总布局之生态文明</h1><p>这一章的逻辑性不太强，随缘记吧。</p>
<a id="more"></a>
<h2 id="坚持人与自然和谐共生"><a href="#坚持人与自然和谐共生" class="headerlink" title="坚持人与自然和谐共生"></a>坚持人与自然和谐共生</h2><p>生态文明的核心是坚持人与自然和谐共生，树立尊重自然，顺应自然，保护自然的生态文明理念。</p>
<h2 id="新时代推进生态文明建设必须坚持的原则"><a href="#新时代推进生态文明建设必须坚持的原则" class="headerlink" title="新时代推进生态文明建设必须坚持的原则"></a>新时代推进生态文明建设必须坚持的原则</h2><h3 id="现实与自然和谐共生"><a href="#现实与自然和谐共生" class="headerlink" title="现实与自然和谐共生"></a>现实与自然和谐共生</h3><h3 id="清绿水青山就是金山银山"><a href="#清绿水青山就是金山银山" class="headerlink" title="清绿水青山就是金山银山"></a>清绿水青山就是金山银山</h3><h3 id="良好的生态环境是最普惠的民生福祉"><a href="#良好的生态环境是最普惠的民生福祉" class="headerlink" title="良好的生态环境是最普惠的民生福祉"></a>良好的生态环境是最普惠的民生福祉</h3><h3 id="山水林田湖草是生命共同体"><a href="#山水林田湖草是生命共同体" class="headerlink" title="山水林田湖草是生命共同体"></a>山水林田湖草是生命共同体</h3><h3 id="用最严格，制度最严密法制保护生态环境"><a href="#用最严格，制度最严密法制保护生态环境" class="headerlink" title="用最严格，制度最严密法制保护生态环境"></a>用最严格，制度最严密法制保护生态环境</h3><h3 id="共谋全球生态文明建设，深度参与全球环境治理"><a href="#共谋全球生态文明建设，深度参与全球环境治理" class="headerlink" title="共谋全球生态文明建设，深度参与全球环境治理"></a>共谋全球生态文明建设，深度参与全球环境治理</h3><h2 id="形成人与自然和谐发展的新格局"><a href="#形成人与自然和谐发展的新格局" class="headerlink" title="形成人与自然和谐发展的新格局"></a>形成人与自然和谐发展的新格局</h2><h2 id="生态文明体系"><a href="#生态文明体系" class="headerlink" title="生态文明体系"></a>生态文明体系</h2><p>包括生态文化体系，生态经济体系，目标责任体系，生态文明制度体系，生态安全体系。</p>
<h2 id="生态文明体制改革"><a href="#生态文明体制改革" class="headerlink" title="生态文明体制改革"></a>生态文明体制改革</h2><p>1推动形成绿色发展方式和生活方式。<br>2着力解决突出的环境问题<br>3加大生态系统保护力度<br>4生态环境监管体制的改革<br>什么意思呢？就是要绿色的发展方式和生活方式就是，在发展的过程中的那些方式，比如企业工厂，那个生产的方式要进行改变，还有人们的消费习惯也要发生改变。着力解决突出的环境问题，就是比如现在很严重的雾霾问题。加大环境保护力度，就是完成生态保护红线永久基本农田，城镇开发边界三条控制线划定工作，这个呢就是国家政策，在对于环境保护上面的一些着力点，它通过这三条边界的划定来与通过与土地相关的一些政策，来保护环境，第4个就是，改革生态监管体制，把机构建立起来，然后强力执行重惩治。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-政治</tag>
      </tags>
  </entry>
  <entry>
    <title>毛中特第十章（四）</title>
    <url>/2019/12/03/%E6%AF%9B%E4%B8%AD%E7%89%B9%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%884%EF%BC%89/</url>
    <content><![CDATA[<h1 id="“五位一体”总布局之社会建设"><a href="#“五位一体”总布局之社会建设" class="headerlink" title="“五位一体”总布局之社会建设"></a>“五位一体”总布局之社会建设</h1><a id="more"></a>
<h2 id="民生水平"><a href="#民生水平" class="headerlink" title="民生水平"></a>民生水平</h2><p>保障和改善民生是推动社会发展的根本目的<br>第1个是发展教育事业<br>第2个是就业质量和人民收入水平<br>第3是社会保障制度<br>第4式，脱贫攻坚战<br>第五是健康中国战略保持人民健康<br>注意第2个和第4个的区别，提高人民收入水平，是指平均的和整体的水平提高，脱贫攻坚战是指贫困人口。其实他们之间可能也还是有逻辑上面的串联吧，比如说你教育，教育搞得好，全民文化水平很高的话，就业质量就会提高，就业质量提高了，收入水平也就会提高，全体的收入水平提高之后就会，像北欧和北欧那边社会社会保障制度会很完善，然后再就是脱贫消除消除贫富差距之间的问题，最后就是，人民的身体健康很重要。</p>
<h2 id="社会治理"><a href="#社会治理" class="headerlink" title="社会治理"></a>社会治理</h2><p>社会治理是非常重要的。<br>在十九大中提出了社会建设的目标要求，就是到2035年blah blahblahblah，然后到本世纪中叶又布啦布啦布啦布啦。<br>那么建设社会治理的建设又有哪些具体措施来实施呢？<br>第1个是要创新，创新社会治理的体制<br>第二是改进社会治理的方式<br>第三是加强预防和化解社会矛盾机制建设<br>第四是加强社会心理服务体系体系建设</p>
<h2 id="国家安全观"><a href="#国家安全观" class="headerlink" title="国家安全观"></a>国家安全观</h2><p>国家安全观就是以人民安全为宗旨，以政治安全为根本，以国家利益至上为准则。<br>为什么要坚持国家安全观呢？国家安全观的必要性，第一是，做到居安思危，是我党治理国家的一个重要原则，第二是发展使安全的基础，安全是发展的保障，只有在安全的情况下，我国才能平稳健康的发展。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-政治</tag>
      </tags>
  </entry>
  <entry>
    <title>毛中特第十章（三）</title>
    <url>/2019/12/03/%E6%AF%9B%E4%B8%AD%E7%89%B9%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<h1 id="“五位一体”总布局之文化建设"><a href="#“五位一体”总布局之文化建设" class="headerlink" title="“五位一体”总布局之文化建设"></a>“五位一体”总布局之文化建设</h1><a id="more"></a>
<h2 id="牢牢掌握意识形态工作领导权"><a href="#牢牢掌握意识形态工作领导权" class="headerlink" title="牢牢掌握意识形态工作领导权"></a>牢牢掌握意识形态工作领导权</h2><p>意识形态工作领导权是非常重要的，因为它决定了我们的旗帜道路和国家政治安全。上层建筑其实是统治阶级的上层建筑。怎么坚定坚定意识形态领导权呢？就是要坚持马克思主义指导地位，构建中国特色社会主义科学，坚持正确的舆论导向，营造良好的网络环境，落实意识形态责任制。</p>
<h2 id="培育和践行社会主义核心价值观"><a href="#培育和践行社会主义核心价值观" class="headerlink" title="培育和践行社会主义核心价值观"></a>培育和践行社会主义核心价值观</h2><p>核心价值观是一个民族的精神纽带，是思想道德基础。<br>社会主义核心价值观：富强，民主，文明，和谐，自由，平等，公正，法治，爱国，敬业，诚信，友善，这个就不再赘述了，都很熟悉了。<br>社会主义核心价值<strong>体系</strong>的基本内容有4个方面，第1个是马克思主义指导思想，第2个是中国特色社会主义共同理想，第3个是以爱国主义为核心的民族精神和以改革创新为核心的时代精神，第4个是社会主义荣辱观。<br>注意社会主义核心价值观与社会主义核心价值体系之间的关系。</p>
<h2 id="坚定文化，自信建设社会主义文化强国"><a href="#坚定文化，自信建设社会主义文化强国" class="headerlink" title="坚定文化，自信建设社会主义文化强国"></a>坚定文化，自信建设社会主义文化强国</h2><p>1个是要有自信心，因为文化自信是非常重要的，其次我们是中国是一个，有着很悠久的和很优秀的传统文化的国家，我们要对这些传统文化进行创新性和创造性的一些改善和发展，以达到发展成为一个文化强国的目标。文化强国有三个衡量的指标，第1个是国民素质，第2个是文化产业的发展，第3个是国家的软实力，所以我们要提高文化产业的发展，还有提高国家文化。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-政治</tag>
      </tags>
  </entry>
  <entry>
    <title>毛中特第十章（二）</title>
    <url>/2019/12/03/%E6%AF%9B%E4%B8%AD%E7%89%B9%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h1 id="“五位一体”总布局之政治建设"><a href="#“五位一体”总布局之政治建设" class="headerlink" title="“五位一体”总布局之政治建设"></a>“五位一体”总布局之政治建设</h1><p><img src="https://wx4.sinaimg.cn/mw690/6a29228bgy1g6y7zl0el5j20zf0zk1kx.jpg" alt="来啦2020"></p>
<a id="more"></a>
<h2 id="坚持中国特色社会主义政治发展道路"><a href="#坚持中国特色社会主义政治发展道路" class="headerlink" title="坚持中国特色社会主义政治发展道路"></a>坚持中国特色社会主义政治发展道路</h2><p>中国特色社会主义是必然结果，也是必然要求，中国特色社会主义包括三方面，一个是党的领导，一个是人民当家作主，还有一个是依法治国，三者要有机统一。人民当家作主是本质，党的领导是根本保证，依法治国是基本方式。<br>走中国特色社会主义政治发展道路必须坚持，正确的政治方向，也就是说，在外界都是资本主义的情况下，我们还能保持，和坚持自己的这条道路，让自己的目标和方向不会发生改变。<br>人民当家作主是社会主义民主政治的本质和核心，人民当家作主的基本内涵，第一是在国体和政体上面属于人民，第二是在法律制度题和体制机制上面属于人民，第三，是国家机关和公务员都是依靠人民的第四，法律法规和方针政策和人民相关地5，国家各方面事业和各方面工作都坚持以人民为中心。</p>
<h2 id="健全人民当家作主制度体系"><a href="#健全人民当家作主制度体系" class="headerlink" title="健全人民当家作主制度体系"></a>健全人民当家作主制度体系</h2><p>第1个是政治制度是人民代表大会制度，是我国的根本政治制度安排。<br>第2个是中国共产党的多党合作和政治协商制度，但是中国共产党的领导是，根本首要前提和根本保证，然后多党合作才是核心内容，就是说中国共产党的领导还是要排在第首位的位置，然后中国共产党与各民主党派的合作基本方针是，长期共存，相互监督，肝胆相照，荣辱与共。人民政协那是一个组织是一种机构。人民政协的主题是团结和民主，主要职能是政治协商，民主监督，参政议政。<br>第3个是民族之民族名民族区域自治制度。就是核心是让少数民族当家作主，但是，要维护国家统一领土完整。<br>第4个是基层群众自治制度。农村村民委员会、城市居民委员会、企业职工代表大会。<br>第5个是社会主义协商民主。协商民主是中国社会主义民主政治的特有形式和独特优势。</p>
<h2 id="巩固和发展爱国统一战线"><a href="#巩固和发展爱国统一战线" class="headerlink" title="巩固和发展爱国统一战线"></a>巩固和发展爱国统一战线</h2><p>第1个方面是各民主党派<br>第2个方面是民族方面<br>第3个方面是宗教方面<br>然后就是要牢牢把握大团结大联合的主题，做好统战工作。统一战线就是从毛泽东开始开始提出的一个思想政策，所以在共产党中间一直很很在意统一战线这一政治方面的因素，这是关系到人心的向背力量的对比是成败的关键因素。</p>
<h2 id="坚持“一国两制”，推进祖国统一"><a href="#坚持“一国两制”，推进祖国统一" class="headerlink" title="坚持“一国两制”，推进祖国统一"></a>坚持“一国两制”，推进祖国统一</h2><p>“一国两制”，“港人治港”，“澳人治澳”，高度自治。<br>从4个方面把握一国两制的问题，第1个是要准确把握一国和两制之间的关系，一国是两制的前提，第2是必须依照宪法和基本法办事，第3是要把发展作为第一要务，第4必须要维护稳定和谐的社会环境。<br>再就是台湾的问题。第1个是一起推进中华民族伟大复兴，第2个是探索一国两制的制度，第3个是，坚持一个中国原则，第4个是融合发展，第5个是心灵契合。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-政治</tag>
      </tags>
  </entry>
  <entry>
    <title>毛中特第十章</title>
    <url>/2019/12/03/%E6%AF%9B%E4%B8%AD%E7%89%B9%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="“五位一体”总体布局经济篇"><a href="#“五位一体”总体布局经济篇" class="headerlink" title="“五位一体”总体布局经济篇"></a>“五位一体”总体布局经济篇</h1><a id="more"></a>
<p>好，我们再来复习一下8个明确中的第2个是，社会矛盾，这个前面已经说过了，我们就不说了，第3个是，明确中国特色社会的事业，总体布局是5位一体，战略布局是4个全面。<br>什么是5位一体的？5位一体在前面背过，就是2020年到2035年之间两步走第1步的，经济建设，政治建设，文化建设，社会建设和生态文明建设的5位一体。五位一体的内容很多，这里只讲经济部分。</p>
<h2 id="贯彻新发展理念"><a href="#贯彻新发展理念" class="headerlink" title="贯彻新发展理念"></a>贯彻新发展理念</h2><p>新发展理念又有5个词叫做创新，协调，绿色，开放，共享。</p>
<h3 id="创新"><a href="#创新" class="headerlink" title="创新"></a>创新</h3><p>注重的是解决发展动力的问题，就是，你要怎么样才能促进发展，你就肯定要创新，你创新的才能让这个世界和这个社会发展起来。</p>
<h3 id="协调"><a href="#协调" class="headerlink" title="协调"></a>协调</h3><p>注重的是解决发展不平衡的问题，因为之前讲到，我国社会主义的主要矛盾已经转变成了发展不平衡不充分的问题，所以我们要协调的发展就是要充分又平衡的发展。</p>
<h3 id="绿色"><a href="#绿色" class="headerlink" title="绿色"></a>绿色</h3><p>就是人与环境自然一些之间的问题，环保之间的问题。</p>
<h3 id="开放"><a href="#开放" class="headerlink" title="开放"></a>开放</h3><p>就是解决内外联动的问题，就是不要，不要太封闭，不要闭关锁国，在把自己关在一个地方搞自己的事情，中国之前不是吃了很多闭关锁国的亏吗？</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>是，解决社会公平正义的问题，就是，嗯，就是，不仅要把蛋糕做大，还要关注蛋糕怎么分的问题。</p>
<h2 id="深化供给侧结构性改革"><a href="#深化供给侧结构性改革" class="headerlink" title="深化供给侧结构性改革"></a>深化供给侧结构性改革</h2><h3 id="深化供给侧改革的必要性"><a href="#深化供给侧改革的必要性" class="headerlink" title="深化供给侧改革的必要性"></a>深化供给侧改革的必要性</h3><p>经济发展面临的问题有两个方面，一个是供给方，一个是需求方，但是我国的经济问题的主要方面还是处在供给方上面的问题，这是我国的现状。<br>所以我们要对供给方进行结构化的改革，<br>结构化的改革怎么改呢？就是要就是要让供给能够更好的满足人民，日益增长的美好生活的需要，<br>解决方法就是比如解放和发展社会生产力，用改革的办法进行结构化的调整，减少无效和低端的供给，扩大和有效和中高端的供给，提高全要素生产率等等等等。</p>
<h3 id="供给侧结构性改革的主要任务"><a href="#供给侧结构性改革的主要任务" class="headerlink" title="供给侧结构性改革的主要任务"></a>供给侧结构性改革的主要任务</h3><p>第1个是，全面提升制造业和实体业的发展。<br>第2个是深化要素市场配置改革，就是让中国的制造业从以价格取胜转化变成以质量取胜，<br>第三是，对人力资源的培养要加大。<br>第四是维持推进三去一降一补。去产能，去库存，去杠杆，降成本，补短板。</p>
<h2 id="建设现代化经济体系的主要任务"><a href="#建设现代化经济体系的主要任务" class="headerlink" title="建设现代化经济体系的主要任务"></a>建设现代化经济体系的主要任务</h2><h2 id="新时代经济发展的基本特征"><a href="#新时代经济发展的基本特征" class="headerlink" title="新时代经济发展的基本特征"></a>新时代经济发展的基本特征</h2><p>是由高速发展向高质量发展转变。</p>
<h2 id="推动高质量发展的原因"><a href="#推动高质量发展的原因" class="headerlink" title="推动高质量发展的原因"></a>推动高质量发展的原因</h2><p>第1个是，为了保持经济的健康的发展，第2个是我国社会基本矛盾已经发生了变化，第3个是经济发展的必然规律。</p>
<h2 id="现代化经济体系的科学内涵"><a href="#现代化经济体系的科学内涵" class="headerlink" title="现代化经济体系的科学内涵"></a>现代化经济体系的科学内涵</h2><p>也就是现代化经济体系的内容。6个体系，一个体制。</p>
<h2 id="建设现代化经济体系的主要任务-1"><a href="#建设现代化经济体系的主要任务-1" class="headerlink" title="建设现代化经济体系的主要任务"></a>建设现代化经济体系的主要任务</h2><p>1，以大力发展实体经济。<br>2，实施创新驱动驱动发展战略。<br>3，就是，第三就是实施乡村振兴战略，这里的乡村主要指的是农村，是农村农业现代化问题，乡村治理体系的一些问题。<br>4，推动城乡区域协调发展，这里的城乡，就是指北京之外的所有的一些小城市。注意第4个和第3个的区别，第3个是指农村，第4个是指，嗯，除大城市之外的一些小城市的一些发展，要平衡要均衡的问题。<br>5，是开放型经济，进行国际化的经济体系和经济形势<br>6，深化经济体制改革，也就是说，对社保啊，还有，产权啊，还有要素市场这方面进行进一步的改革。<br> 最后就是我国是公有制为主体，多种所有制经济共同发展的经济，基本经济制度，这是中国特色社会主义制度的重要组成部分，也就是说，虽然我们是社会主义，但是我们不全是公有制的经济形势，这就是所谓中国特色社会主义的含义，除此之外我们也不能抛弃民营经济，民营经济是我国经济的重要组成部分，我们还要大展大力发展民营民营经济。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-政治</tag>
      </tags>
  </entry>
  <entry>
    <title>毛中特第九章</title>
    <url>/2019/12/03/%E6%AF%9B%E4%B8%AD%E7%89%B9%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="坚持和发展中国特色社会主义的总任务"><a href="#坚持和发展中国特色社会主义的总任务" class="headerlink" title="坚持和发展中国特色社会主义的总任务"></a>坚持和发展中国特色社会主义的总任务</h1><a id="more"></a>
<p>刚刚不是说了什么8个明确嘛，然后第一点就是明确的总任务，总任务分两个，一个是实现中华民族的伟大复兴，还一个是建设社会主义的现代化强国。</p>
<h2 id="中华民族的伟大复兴的中国梦"><a href="#中华民族的伟大复兴的中国梦" class="headerlink" title="中华民族的伟大复兴的中国梦"></a>中华民族的伟大复兴的中国梦</h2><p>中华民族的伟大复兴的另外一种说法就是，中国梦。</p>
<h3 id="中国梦的科学内涵"><a href="#中国梦的科学内涵" class="headerlink" title="中国梦的科学内涵"></a>中国梦的科学内涵</h3><p>第1个是，本质是，国家富强，民族振兴，人民幸福。<br>第2个是中国梦，归根到底说是根是人民的梦，人民是中国梦的主体，是中国梦的创造者和享有者。<br>第3个是，中国梦和全世界人民的梦想是相通的。</p>
<h3 id="奋力实现中国梦就是说"><a href="#奋力实现中国梦就是说" class="headerlink" title="奋力实现中国梦就是说"></a>奋力实现中国梦就是说</h3><p>想要实现中国梦要怎么做呢？<br>第1个就是，走中国道路，弘扬中国精神，凝聚中国力量，中国道路就是中国特色社会主义道路，中国精神就是爱国主义精神，中国中国力量就是各各民族民族大团结的意思。<br>第2个就是实干。有梦想，要实干才能实现。</p>
<h2 id="建设社会主义现代化强国"><a href="#建设社会主义现代化强国" class="headerlink" title="建设社会主义现代化强国"></a>建设社会主义现代化强国</h2><h3 id="怎么建社会主义现代化强国呢——两步走"><a href="#怎么建社会主义现代化强国呢——两步走" class="headerlink" title="怎么建社会主义现代化强国呢——两步走"></a>怎么建社会主义现代化强国呢——两步走</h3><p>第1个阶段就是从2020年到2035年，基本实现社会主义现代化。所以他为什么要唱歌，唱我和2035有个约呢？就是要基本形成社会主义现代化。<br>第2个阶段就是从2035年往后到2020世纪中叶，再奋斗15年，把我国建设成富强民主文明和谐美丽社会主义现代化强国。</p>
<h3 id="那么这个两步走有什么特点呢？"><a href="#那么这个两步走有什么特点呢？" class="headerlink" title="那么这个两步走有什么特点呢？"></a>那么这个两步走有什么特点呢？</h3><p>第1个它提前了15年，虽然我也不知道是什么，提钱的时候反正就提前了15年。<br>第2个就是她把美丽加在了中间。<br>第3个就是他没有再提出什么类似于GDP会翻番的一些内容。</p>
<h3 id="他具体是怎么安排的呢？"><a href="#他具体是怎么安排的呢？" class="headerlink" title="他具体是怎么安排的呢？"></a>他具体是怎么安排的呢？</h3><p>第1步里面呢，就是说要搞经济建设，政治建设，文化建设，社会建设和生态文明建设的5位一体的要求。<br>第2部里面呢，就是要提升物质文明，政治文明，精神文明，社会文明，生态文明。建成富强民主文明和谐美丽的社会主义现代化强国。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-政治</tag>
      </tags>
  </entry>
  <entry>
    <title>毛中特第八章</title>
    <url>/2019/12/03/%E6%AF%9B%E4%B8%AD%E7%89%B9%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="中国特色社会主义进入新时代"><a href="#中国特色社会主义进入新时代" class="headerlink" title="中国特色社会主义进入新时代"></a>中国特色社会主义进入新时代</h1><p>不能放弃，搏一搏单车变摩托。我不指望能考400过初试，让我考个350我就满足了。</p>
<a id="more"></a>
<h2 id="依据"><a href="#依据" class="headerlink" title="依据"></a>依据</h2><p>新的奋斗目标，新的发展阶段，社会主要矛盾，国际地位都发生了变化。</p>
<h2 id="内涵"><a href="#内涵" class="headerlink" title="内涵"></a>内涵</h2><p>是这是一个转折点，承前启后的，继往开来是决胜全面建成小康社会，开始全面建成社会主义现代化强国的时代<br>是实现人民共同富裕，中华民族伟大复兴的时代<br>是我国日益走近，世界舞台中央的时代<br>其实和上面的依据是对应的，新的阶段，新的目标，国际地位</p>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>就是说从中国的角度来看，是一个飞跃。从科学社会角度的，上面来看是一个飞跃。从全人类的文明历史上来看也是一个进步。</p>
<h1 id="我国社会主要矛盾的变化"><a href="#我国社会主要矛盾的变化" class="headerlink" title="我国社会主要矛盾的变化"></a>我国社会主要矛盾的变化</h1><h2 id="依据-1"><a href="#依据-1" class="headerlink" title="依据"></a>依据</h2><p>社会主要矛盾，已经转化为人民日益增长的美好生活，需要和不平衡不，不平衡不充分的发展之间的矛盾，嗯，就是，我国的社会生产力已经得到了很大的提高，人们对社会的需求已经不再只是停留在物质上面的需求而逐渐提高到了一个精神层次上面的需求，影响这些需要的主要的因素是，发展的不平衡和不充分。</p>
<h2 id="我国社会主要矛盾的变化没有改变我过的历史阶段"><a href="#我国社会主要矛盾的变化没有改变我过的历史阶段" class="headerlink" title="我国社会主要矛盾的变化没有改变我过的历史阶段"></a>我国社会主要矛盾的变化没有改变我过的历史阶段</h2><p>就是，我国社会主要矛盾的变化虽然是很重要的，是一个关系全局的，并且是历史性的变化，但是我国的基本国情还是社会主义初级阶段，然后我国的国际地位也还是最大的发展中国家。</p>
<h1 id="习近平新时代中国特色社会主义思想的主要内容"><a href="#习近平新时代中国特色社会主义思想的主要内容" class="headerlink" title="习近平新时代中国特色社会主义思想的主要内容"></a>习近平新时代中国特色社会主义思想的主要内容</h1><h2 id="习近平新时代中国特色社会主义思想的内涵"><a href="#习近平新时代中国特色社会主义思想的内涵" class="headerlink" title="习近平新时代中国特色社会主义思想的内涵"></a>习近平新时代中国特色社会主义思想的内涵</h2><p>8个明确</p>
<h3 id="总任务是实现社会主义现代化，和中华民族伟大复兴矛盾"><a href="#总任务是实现社会主义现代化，和中华民族伟大复兴矛盾" class="headerlink" title="总任务是实现社会主义现代化，和中华民族伟大复兴矛盾"></a>总任务是实现社会主义现代化，和中华民族伟大复兴矛盾</h3><h3 id="矛盾已经说过了"><a href="#矛盾已经说过了" class="headerlink" title="矛盾已经说过了"></a>矛盾已经说过了</h3><h3 id="总体布局是5位一体-4个全面"><a href="#总体布局是5位一体-4个全面" class="headerlink" title="总体布局是5位一体  4个全面"></a>总体布局是5位一体  4个全面</h3><h3 id="总目标是全面深化改革"><a href="#总目标是全面深化改革" class="headerlink" title="总目标是全面深化改革"></a>总目标是全面深化改革</h3><h3 id="总目标是全面推进依法治国，"><a href="#总目标是全面推进依法治国，" class="headerlink" title="总目标是全面推进依法治国，"></a>总目标是全面推进依法治国，</h3><h3 id="建强军目标"><a href="#建强军目标" class="headerlink" title="建强军目标"></a>建强军目标</h3><h3 id="特色大国外交"><a href="#特色大国外交" class="headerlink" title="特色大国外交"></a>特色大国外交</h3><h3 id="最本质是中国共产党的领导。"><a href="#最本质是中国共产党的领导。" class="headerlink" title="最本质是中国共产党的领导。"></a>最本质是中国共产党的领导。</h3><h2 id="坚持和发展中国特色社会主义的基本方略"><a href="#坚持和发展中国特色社会主义的基本方略" class="headerlink" title="坚持和发展中国特色社会主义的基本方略"></a>坚持和发展中国特色社会主义的基本方略</h2><p>14个坚持</p>
<h2 id="历史地位"><a href="#历史地位" class="headerlink" title="历史地位"></a>历史地位</h2><p>一是对马克思主义中国化上面来说，它是最新的成果<br>第二是，新时代的精神旗帜，是国家政治生活和社会生活的根本指针，就是对我国的党章和宪法有影响<br>第三是，是实现中华民族伟大复兴的行动指南，就是。就是在实现中国的一些，嗯目标上面的指导。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-政治</tag>
      </tags>
  </entry>
  <entry>
    <title>如何记忆大段文字并在考试时信手引用？</title>
    <url>/2019/12/03/demo/</url>
    <content><![CDATA[<p><img src="https://wx3.sinaimg.cn/mw690/005Nep6ygy1g8k0p5s3y9j32wv1y41kz.jpg" alt=""></p>
<a id="more"></a>
<p><strong>记忆的一个重要前提：考试要求是对观点能够信手拈来，而论据和观点本身化为己用，并不是一字不差地誊写在卷面上。</strong></p>
<h4 id="不要直接背书上的叙述性文字，要通过自己的语言加工，机械重复并不能加强记忆"><a href="#不要直接背书上的叙述性文字，要通过自己的语言加工，机械重复并不能加强记忆" class="headerlink" title="不要直接背书上的叙述性文字，要通过自己的语言加工，机械重复并不能加强记忆"></a>不要直接背书上的叙述性文字，要通过自己的语言加工，机械重复并不能加强记忆</h4><h4 id="如何进行精细加工？"><a href="#如何进行精细加工？" class="headerlink" title="如何进行精细加工？"></a>如何进行精细加工？</h4><p>记忆书本原有的关键词、知识点等“点”信息，而后自己去连“点”成“线”，把这一块的“点”信息串成有逻辑的内容。<br>怎么联系？记住关键词和知识点之后，记关系：并列？因果？时间？空间？人物？然后合上书本，用自己的逻辑语言系统把关键词串起来。</p>
<blockquote>
<p>《自控力》关于睡眠的表述：<strong>长期睡眠不足</strong>让你更容易感到<strong>压力</strong>、萌生欲望、受到诱惑。还让你很难控制<strong>情绪</strong>、集中<strong>注意力</strong>。<br>关键词已经标出，关系是因果。串起来就是：长期睡眠不足的危害有：压力大、欲望多、情绪暴躁、注意力分散。<br>还可以通过讯飞语记，在无人处出声进行“串起来”，它会把声音转化成文字，然后自行对文字进行修改；之后复习，可直接看自己的文字表述，内容更熟悉，记忆更牢靠。</p>
</blockquote>
<h4 id="先“记少”"><a href="#先“记少”" class="headerlink" title="先“记少”"></a>先“记少”</h4><p>在对书本的第一遍、第二遍记忆时，记少能提高记忆内容的覆盖面，当考试时基本上能够把观点都罗列出来。</p>
<h4 id="后“记多”"><a href="#后“记多”" class="headerlink" title="后“记多”"></a>后“记多”</h4><p>然后开始由少记多，这一过程放在后面几遍的复习过程中。比如某一段重要的文字，你之前记了两个核心观点，在第三遍复习的时候，核心观点已经成为了你的“已有的知识经验”，这时候剩下“相对陌生”的知识与之前记住的知识点有千丝万缕的联系，与已有的知识经验结合记忆，会更高效。</p>
<h4 id="无论时间的多寡，都先记“少”，但如果最后只记住了少，那也很能打"><a href="#无论时间的多寡，都先记“少”，但如果最后只记住了少，那也很能打" class="headerlink" title="无论时间的多寡，都先记“少”，但如果最后只记住了少，那也很能打"></a>无论时间的多寡，都先记“少”，但如果最后只记住了少，那也很能打</h4><p>把其他模块与它相关的知识，往所知的“少”上靠，往深里论述。<br>重要的是答题过程，所体现的思路和思考能力，而非背书天分。</p>
]]></content>
  </entry>
  <entry>
    <title>《数据结构》关键词索引整理（二）</title>
    <url>/2019/12/03/Key-Words-in-Data-Structure2/</url>
    <content><![CDATA[<blockquote>
<p>“  你是我新奇的无尽宝藏<br>    是拂去所有枝叶的百分百现实  ”<br>/ 高村光太郎</p>
</blockquote>
<a id="more"></a>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p><img src="https://wx1.sinaimg.cn/mw690/532c5244gy1g95ux4ffw5j20u01407ql.jpg" alt=""></p>
<h3 id="序列（sequence）、向量（vector）、列表（list）、秩（rank）、位置（position）P28"><a href="#序列（sequence）、向量（vector）、列表（list）、秩（rank）、位置（position）P28" class="headerlink" title="序列（sequence）、向量（vector）、列表（list）、秩（rank）、位置（position）P28"></a>序列（sequence）、向量（vector）、列表（list）、秩（rank）、位置（position）<em>P28</em></h3><p>最基本的线性结构被称为序列，根据数据项的逻辑次序和物理存贮次序是否吻合可以讲其分为向量和列表。在向量中数据项的逻辑次序和物理储存地址的次序相对应，此时的逻辑次序被称为秩。在列表中数据项的逻辑次序和物理存储地址的次序不一定相对应，其用间接定址的方式通过封装后的位置相互引用。</p>
<h3 id="数组（array）P28"><a href="#数组（array）P28" class="headerlink" title="数组（array）P28"></a>数组（array）<em>P28</em></h3><p>若集合S中有n个元素，且元素之间存在着一定的次序，则可以把该数组存储在以A[]为首起始地址的一段连续的存储空间中，并且把他们统称为数组，通常以A[]作为该数组的标识。</p>
<h3 id="前驱（predecessor）、后继（successor）、直接前驱（immediate-predecessor）、直接后继（immediate-predecessor）、前缀（prefix）、后缀（sffix）P28"><a href="#前驱（predecessor）、后继（successor）、直接前驱（immediate-predecessor）、直接后继（immediate-predecessor）、前缀（prefix）、后缀（sffix）P28" class="headerlink" title="前驱（predecessor）、后继（successor）、直接前驱（immediate predecessor）、直接后继（immediate predecessor）、前缀（prefix）、后缀（sffix）P28"></a>前驱（predecessor）、后继（successor）、直接前驱（immediate predecessor）、直接后继（immediate predecessor）、前缀（prefix）、后缀（sffix）<em>P28</em></h3><p>对于任何0&lt;=i&lt;j&lt;=n，A[i]都是A[j]前驱。A[j]都是A[i]的后期。特别的，对于任何i&gt;=1，A[i-1]称作A[i]的直接前驱，对任何i&lt;=n-2，A[i+1]称作A [i]的直接后继。任意元素的所有前驱统称为该元素的前缀，所有后继统称为该元素的后缀。也就是说前驱是指单个元素，后继也是指单个元素，在他前面就是他的前驱在他后面就是他的后继，然后在他前面一个的叫做直接前驱，在他后面一个的叫做直接后继，它的前驱构成的集合叫做前缀，后继构成的集合叫做后缀。</p>
<h3 id="线性数组（liner-array）P28"><a href="#线性数组（liner-array）P28" class="headerlink" title="线性数组（liner array）P28"></a>线性数组（liner array）<em>P28</em></h3><p>如果数组A[]的起始地址为A<br>，s为每个元素所占的空间大小，则元素A[i]的物理地址可以表示为A+i*s，因为元素的存储物理存储地址和它的下标之间存在这种线性关系，所以，被称为线性数组。</p>
<h3 id="向量（vector）基于线性数组（集合）的定义P29"><a href="#向量（vector）基于线性数组（集合）的定义P29" class="headerlink" title="向量（vector）基于线性数组（集合）的定义P29"></a>向量（vector）基于线性数组（集合）的定义<em>P29</em></h3><p>向量是线性数组的一种抽象和泛化，它是由具有线性关系的元素构成的集合，其中元素分别有秩来区分。<br>这几个概念之间的关系就是先引出数组的概念，数组的概念的定义是元素之间有次序关系的集合，放在一个有起始位置的连续的物理存储空间中这样来定义的。然后，再定义的是线性数组，就是解释了为什么数组又被称为线性数组，是因为数组的下标和他的物理存储空间之间存在一种线性的关系。再就是对向量的定，借助线性数组，说是对线性数组的一种抽象和泛化。因为数组本身也是一种集合，所以说在向量的定义中，也说它是一种集合，也说元素之间通过秩来相互区分。</p>
<h3 id="秩（rank）基于前驱的定义P29"><a href="#秩（rank）基于前驱的定义P29" class="headerlink" title="秩（rank）基于前驱的定义P29"></a>秩（rank）基于前驱的定义<em>P29</em></h3><p>各个元素的秩互异，且均为[0,n)之间的整数，若元素一的前区有r个则起秩就是r。</p>
<h3 id="寻秩访问（call-by-rank）P29"><a href="#寻秩访问（call-by-rank）P29" class="headerlink" title="寻秩访问（call-by-rank）P29"></a>寻秩访问（call-by-rank）<em>P29</em></h3><p>反过来通过而亦可获得e=Vr，这是向量特有的元素访问方式，称作寻秩访问访问。就是通过r来访问向量中的元素。</p>
<h3 id="构造函数（constructor）、初始化（initialization）P32"><a href="#构造函数（constructor）、初始化（initialization）P32" class="headerlink" title="构造函数（constructor）、初始化（initialization）P32"></a>构造函数（constructor）、初始化（initialization）<em>P32</em></h3><p>向量也是一种类，类在初始化为对象时，与所有对象一样向量在使用时也需要构造函数，对其进行初始化。</p>
<h3 id="析构函数（destructor）、清理（cleanup）P33"><a href="#析构函数（destructor）、清理（cleanup）P33" class="headerlink" title="析构函数（destructor）、清理（cleanup）P33"></a>析构函数（destructor）、清理（cleanup）<em>P33</em></h3><p>与所有对象一样，向量在不被需要的时候，也要调用构造析构函数对其进行清理，已释放被其占有的系统资源。</p>
<h3 id="上溢（overflow）P33"><a href="#上溢（overflow）P33" class="headerlink" title="上溢（overflow）P33"></a>上溢（overflow）<em>P33</em></h3><p>容量固定不变会导致无法加入更多的元素</p>
<h3 id="装填因子（loadfactor）P33"><a href="#装填因子（loadfactor）P33" class="headerlink" title="装填因子（loadfactor）P33"></a>装填因子（loadfactor）<em>P33</em></h3><p>向量实际规模（size）以及内部数组容量（capacity）的比值，称作装填因子，是衡量空间利用率的重要指标。扩充向量的原理是开辟一个新的向量空间，将原有的向量空间复制进去，且每次新扩充的向量空间是原来的两倍。</p>
<h3 id="野指针（wild-point）P34"><a href="#野指针（wild-point）P34" class="headerlink" title="野指针（wild point）P34"></a>野指针（wild point）<em>P34</em></h3><p>用数组来实现相应复制，空间扩充的时候新的向量，新的数组的指针与原来数组的指针是没有直接的关系的，这样原来指向原来数组的指针失效，变成了野指针。</p>
<h3 id="分摊运行时间（amortized-running-time）P35"><a href="#分摊运行时间（amortized-running-time）P35" class="headerlink" title="分摊运行时间（amortized running time）P35"></a>分摊运行时间（amortized running time）<em>P35</em></h3><p>可扩充向量的足够多次连续操作的时间分摊至每一次操作，如此平摊得到每单次操作的时间叫做分摊操作，分摊运行时间。平均运行时间是乘上概率的，是加权的平均时间。</p>
<h3 id="下溢（underflow-P36"><a href="#下溢（underflow-P36" class="headerlink" title="下溢（underflow)P36"></a>下溢（underflow)<em>P36</em></h3><p>在一系列操作中，若删除的次数远远大于插入的操作，这个时候，装填因子的数值可能会小于远远小于100%，甚至很接近于0，此时我们就称，数组发生了下溢。</p>
<h3 id="无序向量-unsorted-vector-P39"><a href="#无序向量-unsorted-vector-P39" class="headerlink" title="无序向量(unsorted vector)P39"></a>无序向量(unsorted vector)<em>P39</em></h3><p>仅支持对比（==、!=）而不支持比较的能量，被称为无序向量。</p>
<h3 id="顺序查找-sequential-search-P39"><a href="#顺序查找-sequential-search-P39" class="headerlink" title="顺序查找(sequential search)P39"></a>顺序查找(sequential search)<em>P39</em></h3><p>从元素末尾出发，逐一取出各个元素，并与目标元素进行比对，直到发现与之相等，或者将所有元素都比对之后，仍未发现与之相等，这种逐个对比，查找的方式被称为被称为顺序查找。<br>注意比较和对比的区别</p>
<h3 id="输入敏感算法-input-sensitive-P39"><a href="#输入敏感算法-input-sensitive-P39" class="headerlink" title="输入敏感算法(input sensitive)P39"></a>输入敏感算法(input sensitive)<em>P39</em></h3><p>规模相同，内部组成不同，渐进运算时间却有着本质的区别，这种算这种算法被称为输入敏感算法。</p>
<h3 id="错误（error）、意外-expection-P42"><a href="#错误（error）、意外-expection-P42" class="headerlink" title="错误（error）、意外(expection)P42"></a>错误（error）、意外(expection)<em>P42</em></h3><p>输入的参数超过接口范围的这类问题属于经典的错误或者意外，除了基于除此之外还要通过更加周全的设计来解决这个问题。</p>
<h3 id="二分查找法-binary-search-P49"><a href="#二分查找法-binary-search-P49" class="headerlink" title="二分查找法(binary search)P49"></a>二分查找法(binary search)<em>P49</em></h3><p>有序向量中间的元素，作为目标元素的试探对象，以最坏的情况来看，这个解决方法是最优的，因为。无论朝哪个迭代后无论朝哪个方向深入，其问题的规模都将缩小一半，这一策略被称为二分查找查找法。</p>
<h3 id="在线算法和离线算法-offline-algorithm-online-algorithm-P57"><a href="#在线算法和离线算法-offline-algorithm-online-algorithm-P57" class="headerlink" title="在线算法和离线算法(offline algorithm)(online algorithm)P57"></a>在线算法和离线算法(offline algorithm)(online algorithm)<em>P57</em></h3><p>根据输入形式的不同，排序算法可以分为在线算法和离线算法，离线排序是指在待排数据以批处理的方式整体给出。而在线算法是比如网络计算中，待排序的数据要实时生成，算法已经开始，待排的数据才传给算法。</p>
<h3 id="复杂下界-lower-bound）P58"><a href="#复杂下界-lower-bound）P58" class="headerlink" title="复杂下界(lower bound）P58"></a>复杂下界(lower bound）<em>P58</em></h3><p>一般在最坏情况下，得最低计算成本，即为该问题的复杂下界，一个问题，一旦在最坏的情况下达到这个下界，那么也意味着这已经是该问题的最坏情况下的最优解。</p>
<h3 id="比较树（comparison-tree）P58"><a href="#比较树（comparison-tree）P58" class="headerlink" title="比较树（comparison tree）P58"></a>比较树（comparison tree）<em>P58</em></h3><p>内部的每一个节点都对应的是一次比较。左右分支对应的是比较的两种结果，和他下一步将要执行的方向。叶子节点（或叶子节点到根节点的路径）表示的是最终的输出和算法执行的过程，反过来，算法的每一运行过程，都对应于从根到某一叶子节点的路径。</p>
<h3 id="基于比较式的算法CBA算法（comparison-based-algorithm）P58"><a href="#基于比较式的算法CBA算法（comparison-based-algorithm）P58" class="headerlink" title="基于比较式的算法CBA算法（comparison-based algorithm）P58"></a>基于比较式的算法CBA算法（comparison-based algorithm）<em>P58</em></h3><p>无论什么算法，只要他的分支取决于变量或常量的比较结果，那么它的所有的可能的执行过程就可以用比较树来表示，这就是所谓的基于比较式算法，简称CBA式算法。</p>
<h3 id="排序算法的稳定性（unstable-algorithm）P61"><a href="#排序算法的稳定性（unstable-algorithm）P61" class="headerlink" title="排序算法的稳定性（unstable algorithm）P61"></a>排序算法的稳定性（unstable algorithm）<em>P61</em></h3><p>排序算法的稳定性是对排序算法更为细致的要求，简而言之就相同元素之间的相对位置在排序前后保持不变，反之，则是不稳定的排序算法。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构》关键词索引整理（一）</title>
    <url>/2019/12/02/Key-Words-in-Data-Structure/</url>
    <content><![CDATA[<p>既然数据结构会考这种送分题那我就不客气了👌</p>
<a id="more"></a>
<h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="计算科学-computer-science-P2"><a href="#计算科学-computer-science-P2" class="headerlink" title="计算科学(computer science) P2"></a>计算科学(computer science) <em>P2</em></h3><p>科学计算的核心在于研究计算方法与过程，而不仅仅是作为计算工具本身。因此E.Digkstra更倾向于将这门学科称为计算科学(computing science)</p>
<h3 id="排序-sorting-P4"><a href="#排序-sorting-P4" class="headerlink" title="排序(sorting) P4"></a>排序(sorting) <em>P4</em></h3><p>将n个整数按通常的大小次序排成一个非降序列。这类操作统称为排序。</p>
<h3 id="有穷性-finiteness-P6"><a href="#有穷性-finiteness-P6" class="headerlink" title="有穷性(finiteness)P6"></a>有穷性(finiteness)<em>P6</em></h3><p>任意算法都应该在执行有限次基本操作之后终止并给出输出，此即所谓算法的有穷性。</p>
<h3 id="正确性（correctness）P6"><a href="#正确性（correctness）P6" class="headerlink" title="正确性（correctness）P6"></a>正确性（correctness）<em>P6</em></h3><p>所给的输出还应该能够符合由问题本身在事先确定的条件，此即所谓算法的正确性。</p>
<h3 id="退化（degeneracy）P7"><a href="#退化（degeneracy）P7" class="headerlink" title="退化（degeneracy）P7"></a>退化（degeneracy）<em>P7</em></h3><p>除一般情况外，实用的算法还应该能够处理各种极端的输入实例。</p>
<h3 id="鲁棒性（robustness）P7"><a href="#鲁棒性（robustness）P7" class="headerlink" title="鲁棒性（robustness）P7"></a>鲁棒性（robustness）<em>P7</em></h3><p>要求能够尽可能充分地应对退化的情况。</p>
<h3 id="可计算性（computability）P7"><a href="#可计算性（computability）P7" class="headerlink" title="可计算性（computability）P7"></a>可计算性（computability）<em>P7</em></h3><p>就大量应用问题而言，根本就不可能设计出必然终止的算法，从这个意义讲，它们都属于不可解的问题。</p>
<h3 id="难解性（intractability）P8"><a href="#难解性（intractability）P8" class="headerlink" title="难解性（intractability）P8"></a>难解性（intractability）<em>P8</em></h3><p>大量问题的最低求解时间成本都远远超出目前实际系统所能提供的计算能力，这类问题被称为难解问题。</p>
<h3 id="时间复杂度（time-complexity）P8"><a href="#时间复杂度（time-complexity）P8" class="headerlink" title="时间复杂度（time complexity）P8"></a>时间复杂度（time complexity）<em>P8</em></h3><p>执行时间的这一变化趋势可表示为输入规模的一个函数，称作该算法的时间复杂度。</p>
<h3 id="渐进分析（asymptotic-analysis）P9"><a href="#渐进分析（asymptotic-analysis）P9" class="headerlink" title="渐进分析（asymptotic analysis）P9"></a>渐进分析（asymptotic analysis）<em>P9</em></h3><p>在评价算法运行效率时，我们往往可以忽略其处理小规模问题时的能力差异，转而关注其在处理更大规模问题时的表现，这种从长远、更为注重时间复杂度的总体变化趋势和增长速度的策略和方法，即所谓的渐进分析法。</p>
<h3 id="大O记号（big-O-notation）P9"><a href="#大O记号（big-O-notation）P9" class="headerlink" title="大O记号（big-O notation）P9"></a>大O记号（big-O notation）<em>P9</em></h3><p>针对足够大的输入规模n，我们把算法执行时间计为T（n）。T（n）的渐进上界即为O（n）。具体地，若存在正的常数c和函数f（n），使得对于任何n&gt;&gt;2都有</p>
<blockquote>
<p>T（n）&lt;=  c·（f（n））</p>
</blockquote>
<p>则可认为在n足够大之后，f（n）给出了T（n）增长速度的一个渐进上界，此时记之为：</p>
<blockquote>
<p>T（n）=  O（n）</p>
</blockquote>
<p>由这一定义，可导出大O记号的以下性质：</p>
<blockquote>
<p>(1)对于任意常数c&gt;0,有O（f（n））=O（c·f（n））<br>(2)对于任意常数a&gt;b&gt;0，有O（n^a+n^b)=O(n^a)</p>
</blockquote>
<h3 id="图灵机（Turning-Machine）和随机存储机（Random-Access-Machine，RAM）P9"><a href="#图灵机（Turning-Machine）和随机存储机（Random-Access-Machine，RAM）P9" class="headerlink" title="图灵机（Turning Machine）和随机存储机（Random Access Machine，RAM）P9"></a>图灵机（Turning Machine）和随机存储机（Random Access Machine，RAM）<em>P9</em></h3><p>在这些计算模型中，指令语句均可分解为若干次基本操作，比如算数运算、比较、分支、子程序点用与往返等；而在大多素实际的计算环境中，每次这种类型的基本操作都可在常数时间内完成。如此，不妨将T（n）定义为算法所执行基本操作的总次数。</p>
<h3 id="最坏情况（worst-case）P10"><a href="#最坏情况（worst-case）P10" class="headerlink" title="最坏情况（worst case）P10"></a>最坏情况（worst case）<em>P10</em></h3><p>该算法的任何程序所需要的时间绝对不会超过这个情况。</p>
<h3 id="最好情况（best-case）P10"><a href="#最好情况（best-case）P10" class="headerlink" title="最好情况（best case）P10"></a>最好情况（best case）<em>P10</em></h3><h3 id="平均情况（average-case）P10"><a href="#平均情况（average-case）P10" class="headerlink" title="平均情况（average case）P10"></a>平均情况（average case）<em>P10</em></h3><p>按照某种约定的概率分布，将规模为n的所有输入对应的计算时间加权平均。</p>
<h3 id="大欧米茄记号"><a href="#大欧米茄记号" class="headerlink" title="大欧米茄记号"></a>大欧米茄记号</h3><h3 id="空间复杂度（space-complexity）P11"><a href="#空间复杂度（space-complexity）P11" class="headerlink" title="空间复杂度（space complexity）P11"></a>空间复杂度（space complexity）<em>P11</em></h3><p>算法所需存储空间的多少也是衡量其性能的一个重要方面。</p>
<h3 id="常数时间复杂度算法（constant-time-algorithm）P12"><a href="#常数时间复杂度算法（constant-time-algorithm）P12" class="headerlink" title="常数时间复杂度算法（constant-time algorithm）P12"></a>常数时间复杂度算法（constant-time algorithm）<em>P12</em></h3><p>运行时间可表示和度量为T（n） = O（1）的这类算法，统称为“常数时间复杂度算法”。</p>
<h3 id="对数时间复杂度（logarithmic-time-algorithm）P13"><a href="#对数时间复杂度（logarithmic-time-algorithm）P13" class="headerlink" title="对数时间复杂度（logarithmic-time algorithm）P13"></a>对数时间复杂度（logarithmic-time algorithm）<em>P13</em></h3><p>由大O记号定义，在用函数logr(n)界定渐进复杂度时，常底数r的具体值无所谓，故通常不予专门标出而笼统地记作logn ，可直接记作O（logn）。</p>
<h3 id="线性时间复杂度（liner-time-algorithm）P14"><a href="#线性时间复杂度（liner-time-algorithm）P14" class="headerlink" title="线性时间复杂度（liner-time algorithm）P14"></a>线性时间复杂度（liner-time algorithm）<em>P14</em></h3><p>凡运行时间可以表示和度量为T（n）=  O（n）形式的这一类算法。</p>
<h3 id="多项式时间复杂度（polynomial-time-algorithm）P14"><a href="#多项式时间复杂度（polynomial-time-algorithm）P14" class="headerlink" title="多项式时间复杂度（polynomial-time algorithm）P14"></a>多项式时间复杂度（polynomial-time algorithm）<em>P14</em></h3><p>若运行时间可以表示和度量为T（n）= O（f（n））的形式，而且f（x）为多项式。</p>
<h3 id="可有效求解-易解性（tractable）P14"><a href="#可有效求解-易解性（tractable）P14" class="headerlink" title="可有效求解/易解性（tractable）P14"></a>可有效求解/易解性（tractable）<em>P14</em></h3><p>在多项式时间复杂度范围内的算法，被称为有效求解的或易解的。</p>
<h3 id="指数时间复杂度算法（exponential-time-algorithm）P15"><a href="#指数时间复杂度算法（exponential-time-algorithm）P15" class="headerlink" title="指数时间复杂度算法（exponential-time algorithm）P15"></a>指数时间复杂度算法（exponential-time algorithm）<em>P15</em></h3><p>凡运行时间可以表示和度为T（n）= O（a^n）形式的算法（a&gt;1)</p>
<h3 id="难解（intractable）P15"><a href="#难解（intractable）P15" class="headerlink" title="难解（intractable）P15"></a>难解（intractable）<em>P15</em></h3><p>不在多项式复杂度算法的问题</p>
<h3 id="伪对数（pseudo-logarithm）和伪线性（pseudo-liner）的复杂度P16"><a href="#伪对数（pseudo-logarithm）和伪线性（pseudo-liner）的复杂度P16" class="headerlink" title="伪对数（pseudo-logarithm）和伪线性（pseudo-liner）的复杂度P16"></a>伪对数（pseudo-logarithm）和伪线性（pseudo-liner）的复杂度<em>P16</em></h3><p>对待计算问题的输入规模，应严格定义为“用以描述输入所需的空间规模”。有的算法以输入参数n本身的数值作为基准而得出的O（logn）和O（n）复杂度，应该用参数n二进制展开的宽度r作为输入规模更为合理，也就是用O（r）和O（2^r）。</p>
<h3 id="递归调用（recursive-call）P16"><a href="#递归调用（recursive-call）P16" class="headerlink" title="递归调用（recursive call）P16"></a>递归调用（recursive call）<em>P16</em></h3><p>递归则是函数和过程点用的一种特殊形式，即允许函数和过程进行自我调用。</p>
<h3 id="递归基（base-case-of-recursion）P17"><a href="#递归基（base-case-of-recursion）P17" class="headerlink" title="递归基（base case of recursion）P17"></a>递归基（base case of recursion）<em>P17</em></h3><p>首先判断平凡情况的，以免因无限递归而导致系统溢出。</p>
<h3 id="线性递归（linear-recursion）P17"><a href="#线性递归（linear-recursion）P17" class="headerlink" title="线性递归（linear recursion）P17"></a>线性递归（linear recursion）<em>P17</em></h3><p>每一层次上至多只有一个实例，而且它们构成一个线性的次序关系。</p>
<h3 id="减而治之（decrease-and-conquer）P17"><a href="#减而治之（decrease-and-conquer）P17" class="headerlink" title="减而治之（decrease-and-conquer）P17"></a>减而治之（decrease-and-conquer）<em>P17</em></h3><p>线性递归的模式，往往对应于所谓减而治之的算法策略：递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡的小（简单）问题。</p>
<h3 id="递归跟踪（recursion-trace）P17"><a href="#递归跟踪（recursion-trace）P17" class="headerlink" title="递归跟踪（recursion trace）P17"></a>递归跟踪（recursion trace）<em>P17</em></h3><p>作为一种直观且可视的方法，可用于分析递归算法的总体运行时间与空间，具体就是按以下原则，将递归算法的执行过程整理为图的形式：</p>
<blockquote>
<p>算法的每一递归实例都表示为一个方框，其中注明了该实例调用的参数<br>若实例M调用实例N，则在M与N对应的方框之间添加一条有向联线</p>
</blockquote>
<h3 id="递推方程（recurrence-equation）P19"><a href="#递推方程（recurrence-equation）P19" class="headerlink" title="递推方程（recurrence equation）P19"></a>递推方程（recurrence equation）<em>P19</em></h3><p>与跟踪分析相反，该方法无需绘出具体的调用过程，而是通过对递归模式的数学归纳，导出复杂度定界函数的递推方程（组）及其边界条件，从而将复杂度的分析，转化为递归方程（组）的求解。</p>
<h3 id="函数重载（overload）P20"><a href="#函数重载（overload）P20" class="headerlink" title="函数重载（overload）P20"></a>函数重载（overload）<em>P20</em></h3><p>函数重载机制定义了名称相同、参数表有别的函数。</p>
<h3 id="尾递归（tail-recursion）P22"><a href="#尾递归（tail-recursion）P22" class="headerlink" title="尾递归（tail recursion）P22"></a>尾递归（tail recursion）<em>P22</em></h3><p>在线性递归算法中，若递归调用在递归实例中恰好以最后一步操作的形式出现，则称作尾递归。</p>
<h3 id="分而治之（divide-and-conquer）P22"><a href="#分而治之（divide-and-conquer）P22" class="headerlink" title="分而治之（divide-and-conquer）P22"></a>分而治之（divide-and-conquer）<em>P22</em></h3><p>就是将问题分解为若干规模更小的子问题，再通过递归机制分别求解。这种分解持续进行，直到子问题规模缩减至平凡情况。</p>
<h3 id="多路递归（multi-way-recursion）P23"><a href="#多路递归（multi-way-recursion）P23" class="headerlink" title="多路递归（multi-way recursion）P23"></a>多路递归（multi-way recursion）<em>P23</em></h3><p>与减而治之的策略一样，这里也对原问题重新表述，以保证子问题与原问题在接口形式上的一致。既然每一递归实例都可能做多次递归，故称作“多路递归”。通常将问原问题一分为二，故称作“二分递归”（binary recursion）。要强调的是，无论是分解为两个还是更大常数个子问题，对算法总体的渐进复杂并无实质影响。</p>
<h3 id="制表（tabulation）-记忆（memoization）P25"><a href="#制表（tabulation）-记忆（memoization）P25" class="headerlink" title="制表（tabulation）/记忆（memoization）P25"></a>制表（tabulation）/记忆（memoization）<em>P25</em></h3><p>可以从原问题出发自顶而下，每当遇到一个子问题，都首先检查它是否已经计算过，以其通过直接调阅记录获得解答，从而避免重新计算。</p>
<h3 id="动态规划（dynamic-programming）P25"><a href="#动态规划（dynamic-programming）P25" class="headerlink" title="动态规划（dynamic programming）P25"></a>动态规划（dynamic programming）<em>P25</em></h3><p>可以递归基出发，自底而上递推地得出各子问题的解，直至最终原问题的解。</p>
<h3 id="抽象数据类型（abstract-data-type，ADT）P26"><a href="#抽象数据类型（abstract-data-type，ADT）P26" class="headerlink" title="抽象数据类型（abstract data type，ADT）P26"></a>抽象数据类型（abstract data type，ADT）<em>P26</em></h3><p>数据集合及其对应的操作可超脱于具体的程序设计语言、具体的实现方式，即构成所谓的抽象数据类型。</p>
<h3 id="接口（interface）、实现（implementation）P26"><a href="#接口（interface）、实现（implementation）P26" class="headerlink" title="接口（interface）、实现（implementation）P26"></a>接口（interface）、实现（implementation）<em>P26</em></h3><p>具体将从数据结构的对外接口出发，以c++语言为例，逐层讲解其内部具体实现的原理、方法与技巧，并就不同实现方式的效率及实用范围进行分析与比较。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>hoxe系列（一）搭建博客网站</title>
    <url>/2019/12/02/page/</url>
    <content><![CDATA[<blockquote>
<p>“  真正被爱的人在爱人眼里是绽放的丁香，航船渔火，学校铃声，山水风景，难以忘怀的谈话，朋友，孩子的周日，消逝的声音，最心爱的衣服，秋天和所有的季节。 ”<br>/ 杜鲁门·卡波特《别的声音，别的房间》</p>
</blockquote>
<a id="more"></a>
<p>早就想搭建一个个人博客了，因为一直以来都挺喜欢写写文字记录一下感想和生活的。但是本菜鸡断断续续地学了半年前端、H5、CSS、Js甚至还涉及到了React还有flutter，但是都因为觉得自己搭站工程巨大，遥遥无期，都没有坚持，半途而废了。无意中看别人的博客，发现用hexo和git一起搭建个人博客还是挺简单的，自己试了下，大概用了两个小时就搭建完成了。美滋滋。写篇文章得瑟一下。</p>
<h4 id="搭建环境："><a href="#搭建环境：" class="headerlink" title="搭建环境："></a>搭建环境：</h4><p>Caralina 10.15.1</p>
<h4 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h4><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>在官网上下载了pkg，双击安装。<br>git电脑上默认就安装了。</p>
<p>安装好Node.js以后，使用npm完成对hexo的安装。打开终端，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span></pre></td></tr></table></figure>
<p>视个人网速等待一会之后，hexo就安装完成了。</p>
<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>先在自己喜欢的任何地方建一个文件夹，终端输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init _folder_</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ cd folder</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ npm install</span></pre></td></tr></table></figure>
<p>这时我们的博客雏形其实已经搭建好了，文件内容已经由hexo帮我们生成了建站所有需要的文件。<br>首先我们先关注根目录下的_config.yml文件，它包括了网站需要的配置信息，可以配置绝大部分的参数。<br>首先我们一定要改的一般是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: your website title</span></pre></td></tr><tr><td class="code"><pre><span class="line">subtitle: xxxx</span></pre></td></tr><tr><td class="code"><pre><span class="line">author: your name</span></pre></td></tr><tr><td class="code"><pre><span class="line">url: 你挂靠的网页的网址（这个我们会在下文提到）</span></pre></td></tr></table></figure>
<p>别的可以暂时用默认值。<br>其中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: landscape#是我们马上要继续讲的主题</span></pre></td></tr></table></figure>
<p><strong>重要的是，冒号后面一定要有英文半角的空格</strong><br>剩下目前我们就需要关注两个文件夹：<br><strong>source:</strong>存放我们写的文章和草稿<br><strong>theme:</strong>主题文件夹。hexo就是根据它来生成我们的网页页面，网站最终会是什么样子的，就依靠这个来决定。这个<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">知乎</a>链接里有主题的评星、链接和示例图，大家可以用来参考选择。<br>现在先不管这两个文件夹，再次回到termial，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d -g</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo server</span></pre></td></tr></table></figure>
<p>其中d指deploy也就是部署，-g指generate，表示如果部署时还没生成静态页面就先执行generate，这实际上是两个操作，我们这里一步来完成。等一小段时间，网页就部署好了，这时候输入第二行代码，terminal上会显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;0.0.0.0:4000&#x2F;. Press Ctrl+C to stop.</span></pre></td></tr></table></figure>
<p>我们在浏览器中输入<a href="http://0.0.0.0:4000就能看到刚才的部署的页面了，就是我们博客的样子～" target="_blank" rel="noopener">http://0.0.0.0:4000就能看到刚才的部署的页面了，就是我们博客的样子～</a><br>现在只能本地访问，如果我们希望其他人也能看到，就需要将网页部署到某个服务上去。我选择了github，其他方式操作应该也是类似的。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>首先要注册一个github的账号，然后按照<a href="https://pages.github.com/" target="_blank" rel="noopener">Github Page</a>这上面的步骤，我们就能获得一个类似于https://<em>usernam</em>.github.io的域名地址。同时我们在github上也有一个对应的repository，用来存放我们页面的内容。<br>这时候，打开前面提到的根目录下的_config.yml，在url后填入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: https:&#x2F;&#x2F;username.github.io#对应你自己的地址</span></pre></td></tr></table></figure>
<p>在文件底部的deploy填入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span></pre></td></tr><tr><td class="code"><pre><span class="line">type: git</span></pre></td></tr><tr><td class="code"><pre><span class="line">repo: &lt;repositoty url&gt; #前面获得域名时创建的repository地址,注意和前面的那个url是不一样的，这里是repository的地址，在github上可以看到</span></pre></td></tr><tr><td class="code"><pre><span class="line">branch: [branch] #要发布内容的分支，一般是master</span></pre></td></tr><tr><td class="code"><pre><span class="line">message: [message] ##自定义提交信息，留空就可以。</span></pre></td></tr></table></figure>
<p>这时我们再打开terminal，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d -g</span></pre></td></tr></table></figure>
<p>我在这里出现了报错，提示无法链接git或者找不到git，解决办法是安装<code>hexo-deployer-git</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span></pre></td></tr></table></figure>
<p>这个地方提示要输入GitHub的账号和密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Username for GitHub:</span></pre></td></tr><tr><td class="code"><pre><span class="line">Password for GitHub:</span></pre></td></tr></table></figure>
<p>网页就被部署到<a href="https://username.github.io上了，稍等几分钟，在浏览器的地址栏输入，就能访问博客。" target="_blank" rel="noopener">https://username.github.io上了，稍等几分钟，在浏览器的地址栏输入，就能访问博客。</a><br>至此，博客建站完毕。</p>
<h3 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h3><p>在前文提到过的source文件夹下，新建一个*.md文件，想写的内容填进去，重新生成、部署，稍等会就能看到我们更新的博客了。</p>
<h3 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h3><p>其他还有一些博客管理内容，比如google analytical统计，dispute评论栏，都可以很简单的添加到页面中。在后面对blog的完善中会继续提到。</p>
]]></content>
      <categories>
        <category>-学习</category>
      </categories>
      <tags>
        <tag>-建站 - hoxe</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/01/hello-world/</url>
    <content><![CDATA[<p>欢迎来到菜鸡Kaia的部落格。<br>分享生活和学习的日常。<br>望常更新：）<br>接受催更。</p>
]]></content>
      <categories>
        <category>-生活</category>
      </categories>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Key_Words_in_Date_Structure5</title>
    <url>/2019/12/06/Key-Words-in-Date-Structure5/</url>
    <content><![CDATA[<h1 id="第五章-二叉树"><a href="#第五章-二叉树" class="headerlink" title="第五章 二叉树"></a>第五章 二叉树</h1><a id="more"></a>
<h3 id="线性结构（linear-structure）P110"><a href="#线性结构（linear-structure）P110" class="headerlink" title="线性结构（linear structure）P110"></a>线性结构（linear structure）<em>P110</em></h3><p>元素之间存在一个自然的线性次序，故它们都属于所谓的线性结构。</p>
<h3 id="半线性结构（semi-linear-structure）"><a href="#半线性结构（semi-linear-structure）" class="headerlink" title="半线性结构（semi-linear structure）"></a>半线性结构（semi-linear structure）</h3><p>树则不然，元素之间并不存在天然的直接后继或直接前驱关系，只要附加某种约束（比如遍历），也可以在树中的元素之间确定某种线性次序，因此属于半线性结构。</p>
<h3 id="顶点（vertex）、边（edge）、根（root）、节点（node）、有根树（rooted-tree）P110"><a href="#顶点（vertex）、边（edge）、根（root）、节点（node）、有根树（rooted-tree）P110" class="headerlink" title="顶点（vertex）、边（edge）、根（root）、节点（node）、有根树（rooted tree）P110"></a>顶点（vertex）、边（edge）、根（root）、节点（node）、有根树（rooted tree）<em>P110</em></h3><p>从图论的角度看，树等价于连通无环图，因此与图一样，树也由一组顶点、以及连接与其间的若干条边组成，在计算机科学中，还会制定某一特定顶点并称之为根。在指定根节点之后，我们也称之为有根树。从程序的角度看，我们更多地将顶点称作节点。</p>
<h3 id="祖先（ancestor）、后代（descendant）、真祖先（properancestor）、真后代（proper-descendant）P111"><a href="#祖先（ancestor）、后代（descendant）、真祖先（properancestor）、真后代（proper-descendant）P111" class="headerlink" title="祖先（ancestor）、后代（descendant）、真祖先（properancestor）、真后代（proper descendant）P111"></a>祖先（ancestor）、后代（descendant）、真祖先（properancestor）、真后代（proper descendant）<em>P111</em></h3><p>任一节点v在通往树根沿途径所经过的每一个节点都称为他的祖先，v是它们的后代。特别指出的是，v的祖先/后代包括其本身，而v本身以外的祖先/后代称作真祖先/真后代。</p>
<h3 id="父亲（parent）、孩子（child）P111"><a href="#父亲（parent）、孩子（child）P111" class="headerlink" title="父亲（parent）、孩子（child）P111"></a>父亲（parent）、孩子（child）<em>P111</em></h3><p>节点v历代祖先的层次，自下而上以1为单位逐层递减；在每一层上，v的祖先至多一个。特别地，若节点u是v的祖先且恰好比v高出一层，则称u是v的父亲，v是u的孩子。</p>
<h3 id="度数-度（degree）、叶节点（leaf）、内部节点（internal-node）P111"><a href="#度数-度（degree）、叶节点（leaf）、内部节点（internal-node）P111" class="headerlink" title="度数/度（degree）、叶节点（leaf）、内部节点（internal node）P111"></a>度数/度（degree）、叶节点（leaf）、内部节点（internal node）<em>P111</em></h3><p>任一节点v的孩子总数，称作其度数或度。无孩子的节点称作叶节点，包括根在内的其余节点皆为内部节点。</p>
<h3 id="子树（subtree）P111"><a href="#子树（subtree）P111" class="headerlink" title="子树（subtree）P111"></a>子树（subtree）<em>P111</em></h3><p>任一节点v的所有后代及其之间的联边称作子树，记作subtree（v），我们往往不区分节点（v）以及以之为根的子树subtree（v）。</p>
<h3 id="高度（height）P111"><a href="#高度（height）P111" class="headerlink" title="高度（height）P111"></a>高度（height）<em>P111</em></h3><p>树T中所有节点深度的最大值称作该树的高度。</p>
<h3 id="二叉树（binary-tree）P111"><a href="#二叉树（binary-tree）P111" class="headerlink" title="二叉树（binary tree）P111"></a>二叉树（binary tree）<em>P111</em></h3><p>二叉树中每个节点的度数均不超过2。</p>
<h3 id="有序二叉树（ordered-binary-tree）P111"><a href="#有序二叉树（ordered-binary-tree）P111" class="headerlink" title="有序二叉树（ordered binary tree）P111"></a>有序二叉树（ordered binary tree）<em>P111</em></h3><p>在二叉树中，同一父节点的孩子都可以以左、右相互区分——此时，亦称作有序二叉树。</p>
<h3 id="真二叉树（proper-binary-tree）P111"><a href="#真二叉树（proper-binary-tree）P111" class="headerlink" title="真二叉树（proper binary tree）P111"></a>真二叉树（proper binary tree）<em>P111</em></h3><p>不含一度节点的二叉树称作真二叉树。</p>
<h3 id="多叉树（k-ary-tree）P112"><a href="#多叉树（k-ary-tree）P112" class="headerlink" title="多叉树（k-ary tree）P112"></a>多叉树（k-ary tree）<em>P112</em></h3><p>一般地，树中各节点的孩子数目并不确定，每个节点的孩子均不超过k个的有根树，称作k叉树。</p>
<h3 id="有序多叉树（odered-tree）P113"><a href="#有序多叉树（odered-tree）P113" class="headerlink" title="有序多叉树（odered tree）P113"></a>有序多叉树（odered tree）<em>P113</em></h3>]]></content>
      <categories>
        <category>-考研</category>
      </categories>
      <tags>
        <tag>-datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>Key_Words_in_Date_Structure4</title>
    <url>/2019/12/06/Key-Words-in-Date-Structure4/</url>
    <content><![CDATA[<h1 id="第四章栈与队列"><a href="#第四章栈与队列" class="headerlink" title="第四章栈与队列"></a>第四章栈与队列</h1><a id="more"></a>
<h3 id="栈（stack）P86"><a href="#栈（stack）P86" class="headerlink" title="栈（stack）P86"></a>栈（stack）<em>P86</em></h3><p>栈是存放数据对象的一种特殊容器，其中的数据元素按线性的逻辑次序排列，故可以定义首、末元素。栈结构支持插入和删除操作，但仅限于某特定的一段，禁止操作的一端被称作盲端。</p>
<h3 id="栈顶（stack-top）、栈底（stack-bottom）P87"><a href="#栈顶（stack-top）、栈底（stack-bottom）P87" class="headerlink" title="栈顶（stack top）、栈底（stack bottom）P87"></a>栈顶（stack top）、栈底（stack bottom）<em>P87</em></h3><p>栈中可操作的一端称为栈顶，而另一端无法直接操作的盲端称为栈底。</p>
<h3 id="入栈（push）、出栈（pop）"><a href="#入栈（push）、出栈（pop）" class="headerlink" title="入栈（push）、出栈（pop）"></a>入栈（push）、出栈（pop）</h3><p>栈的插入和删除分别称为入栈和出栈。</p>
<h3 id="后进先出（last-in-first-out，LIFO）"><a href="#后进先出（last-in-first-out，LIFO）" class="headerlink" title="后进先出（last-in-first-out，LIFO）"></a>后进先出（last-in-first-out，LIFO）</h3><p>由于栈位置的约定和限制可知，栈中的元素必然遵循“后进先出”的规律，从栈的整个生命周期来看，最先进入栈的元素会最后出栈，最后入栈的元素会最先出栈。</p>
<h3 id="点用栈（call-stack）、执行栈（execution-stack）P89"><a href="#点用栈（call-stack）、执行栈（execution-stack）P89" class="headerlink" title="点用栈（call stack）、执行栈（execution stack）P89"></a>点用栈（call stack）、执行栈（execution stack）<em>P89</em></h3><p>在大多数操作系统中，每一个运行中的二进制程序都配有一个调用栈或执行栈，借助点用栈可以跟踪属于同一程序的所有函数，记录它们之间的相互调用关系，并保证在每一调用实例执行完毕之后，可以准确地返回。</p>
<h3 id="帧（frame）、返回地址（return-address）P89"><a href="#帧（frame）、返回地址（return-address）P89" class="headerlink" title="帧（frame）、返回地址（return address）P89"></a>帧（frame）、返回地址（return address）<em>P89</em></h3><p>调用栈的基本单位是帧，每次调用函数时，都会相应地创建一帧，记录该函数实例在二进制程序中的返回地址，以及局部变量、传人参数等，并将该帧压入调用栈。</p>
<h3 id="活跃函数实例（active-function-instance）P89"><a href="#活跃函数实例（active-function-instance）P89" class="headerlink" title="活跃函数实例（active function instance）P89"></a>活跃函数实例（active function instance）<em>P89</em></h3><p>在任一时刻，调用栈中的各帧，依次对应于那些尚未返回的调用实例，亦即当时的活跃函数实例。</p>
<h3 id="逆波兰表达式（reverse-Polish-notation-RPN）P96"><a href="#逆波兰表达式（reverse-Polish-notation-RPN）P96" class="headerlink" title="逆波兰表达式（reverse Polish notation,RPN）P96"></a>逆波兰表达式（reverse Polish notation,RPN）<em>P96</em></h3><p>逆波兰表达式是数学表达式的一种，其语法规则可概括为：操作符紧邻于对应的（最后一个）操作数之后。</p>
<h3 id="后缀表达式（postfix）、中缀表达式（infix）P97"><a href="#后缀表达式（postfix）、中缀表达式（infix）P97" class="headerlink" title="后缀表达式（postfix）、中缀表达式（infix）P97"></a>后缀表达式（postfix）、中缀表达式（infix）<em>P97</em></h3><p>RPN亦称作后缀表达式，原表达式亦称作中缀表达式。</p>
<h3 id="剪枝（pruning）P99"><a href="#剪枝（pruning）P99" class="headerlink" title="剪枝（pruning）P99"></a>剪枝（pruning）<em>P99</em></h3><p>基于对应用问题的深刻理解，利用问题本身具有的某些规律尽可能多、尽可能早地排除搜索空间中的候选解。其中一种重要的技巧就是，根据候选解的某些局部特征，以候选解子集为单位批量地排除。搜索空间多呈树状结构，而被排除的候选解往往隶属于同一分枝，故这一技巧也可以形象地称作剪枝。</p>
<h3 id="试探（probing）P99"><a href="#试探（probing）P99" class="headerlink" title="试探（probing）P99"></a>试探（probing）<em>P99</em></h3><p>剪枝对应的算法多呈现为如下模式：从零开始，尝试逐步增加候选解的长度，这一过程是在成批地考察具有特定前缀的所有候选解，这种从长度是上逐步向目标靠近的尝试，称作试探。</p>
<h3 id="回溯（backtracking）P99"><a href="#回溯（backtracking）P99" class="headerlink" title="回溯（backtracking）P99"></a>回溯（backtracking）<em>P99</em></h3><p>作为解的局部特征，特征前缀在试探的过程中一旦被发现与目标解不合，则收缩到前一步的长度，然后继续下一可能的组合。特征前缀长度缩减的这类操作，称作回溯。</p>
<h3 id="队列（queue）、队头（front）、队尾（rear）P105"><a href="#队列（queue）、队头（front）、队尾（rear）P105" class="headerlink" title="队列（queue）、队头（front）、队尾（rear）P105"></a>队列（queue）、队头（front）、队尾（rear）<em>P105</em></h3><p>队列也是存放数据对象的一种容器，其中的数据对象也按线性的逻辑次序排列。队列结构同样支持对象的插入和删除，但两种操作的范围分别被限制于队列的两端——若约定新对象只能从某一端插入其中，则只能从另一端删除已有的元素。允许取出元素的一端作队头，而允许插入元素的另一端称作队尾。</p>
<h3 id="入队（enqueue）、出队（dequeue）P105"><a href="#入队（enqueue）、出队（dequeue）P105" class="headerlink" title="入队（enqueue）、出队（dequeue）P105"></a>入队（enqueue）、出队（dequeue）<em>P105</em></h3><p>元素的插入与删除也是修改队列结构的两种主要方式，站在被操作对象的角度，分别称作入队、出队。</p>
<h3 id="先进先出（first-in-first-out，FIFO）P105"><a href="#先进先出（first-in-first-out，FIFO）P105" class="headerlink" title="先进先出（first-in-first-out，FIFO）P105"></a>先进先出（first-in-first-out，FIFO）<em>P105</em></h3><p>由队列的约定和限制不难看出，与栈结构相反，队列中各对象的操作次序遵循先进先出（first-in-first-out）的规律，更早（晚）出队的元素应该为更早（晚）入队者，反之，更早（晚）入队者应更早（晚）出队。</p>
]]></content>
      <categories>
        <category>-考研</category>
      </categories>
      <tags>
        <tag>-datastructure</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构》关键词索引（三）</title>
    <url>/2019/12/04/Key-Words-in-Data-Structure3/</url>
    <content><![CDATA[<h1 id="第三章列表"><a href="#第三章列表" class="headerlink" title="第三章列表"></a>第三章列表</h1><a id="more"></a>
<h3 id="列表（list）、位置（position）、寻位置访问（call-by-position）、链接（link）、寻链接访问（call-by-link）P66-列表的列表中的元素之间的逻辑结构是相邻的，但是元素之间的物理存储位置却不一定是相邻的，为了保证能够对列表中的元素进行访问，前驱和后继之间应该保持一种一种索引的关系，这种索引的关系就被抽象为位置，所以列表的访问方式称为寻位置访问，或者说可以把这种索引关系抽象为链接，那么那么列表的访问方式也可以被称作寻群链接访问。"><a href="#列表（list）、位置（position）、寻位置访问（call-by-position）、链接（link）、寻链接访问（call-by-link）P66-列表的列表中的元素之间的逻辑结构是相邻的，但是元素之间的物理存储位置却不一定是相邻的，为了保证能够对列表中的元素进行访问，前驱和后继之间应该保持一种一种索引的关系，这种索引的关系就被抽象为位置，所以列表的访问方式称为寻位置访问，或者说可以把这种索引关系抽象为链接，那么那么列表的访问方式也可以被称作寻群链接访问。" class="headerlink" title="列表（list）、位置（position）、寻位置访问（call-by-position）、链接（link）、寻链接访问（call-by-link）P66 列表的列表中的元素之间的逻辑结构是相邻的，但是元素之间的物理存储位置却不一定是相邻的，为了保证能够对列表中的元素进行访问，前驱和后继之间应该保持一种一种索引的关系，这种索引的关系就被抽象为位置，所以列表的访问方式称为寻位置访问，或者说可以把这种索引关系抽象为链接，那么那么列表的访问方式也可以被称作寻群链接访问。"></a>列表（list）、位置（position）、寻位置访问（call-by-position）、链接（link）、寻链接访问（call-by-link）<em>P66</em> 列表的列表中的元素之间的逻辑结构是相邻的，但是元素之间的物理存储位置却不一定是相邻的，为了保证能够对列表中的元素进行访问，前驱和后继之间应该保持一种一种索引的关系，这种索引的关系就被抽象为位置，所以列表的访问方式称为寻位置访问，或者说可以把这种索引关系抽象为链接，那么那么列表的访问方式也可以被称作寻群链接访问。</h3><h3 id="列表（list）P66"><a href="#列表（list）P66" class="headerlink" title="列表（list）P66"></a>列表（list）<em>P66</em></h3><p>列表的元素之间的逻辑上，虽然要求具有连续性，但是其物理存储地址上并没有要求有连续性，此所谓动态存储策略。</p>
<h3 id="链表（linked-list）P66"><a href="#链表（linked-list）P66" class="headerlink" title="链表（linked list）P66"></a>链表（linked list）<em>P66</em></h3><p>链表就是一种典型的动态存储的结构，在动态存储结构中，数据被分为一个个节点，节点之间通过指针相互索引和访问，为了引入新的节点或者删除节点，只需要在局部调整少量几点之间的指针就可以了，相比起来，采用动态存储策略可以大大减少动态操作的成本。</p>
<h3 id="列表（list）P67"><a href="#列表（list）P67" class="headerlink" title="列表（list）P67"></a>列表（list）<em>P67</em></h3><p>列表是一个集合，在这个集合中所有元素之间都具有一定的线性逻辑次序。列表结构是链表结构的一般化推广，其中的元素被称为节点，节点通过链接和通过链接和位置来指代。在元素中也可以定以前缺后继也直接前去直接后继，对于任意元素也定义有相对应的前缀后缀等子集。</p>
<h3 id="头节点（header）、尾节点（trailer）、首节点（first-node）、末节点（last-node）、哨兵节点（sentinel-node）P71"><a href="#头节点（header）、尾节点（trailer）、首节点（first-node）、末节点（last-node）、哨兵节点（sentinel-node）P71" class="headerlink" title="头节点（header）、尾节点（trailer）、首节点（first node）、末节点（last node）、哨兵节点（sentinel node）P71"></a>头节点（header）、尾节点（trailer）、首节点（first node）、末节点（last node）、哨兵节点（sentinel node）<em>P71</em></h3><p>list对象内部组成中，头节点、尾节点始终存在，但对外并不可见。对外部可见的数据节点如果存在，则其中第一个和最后一个节点分别称为首节点和末节点。头节点紧邻于首节点之前，尾节点紧邻于末节点之后，这类经封装后对外部不可见的节点称为哨兵节点。</p>
<h3 id="有序列表（sorted-list）P77"><a href="#有序列表（sorted-list）P77" class="headerlink" title="有序列表（sorted list）P77"></a>有序列表（sorted list）<em>P77</em></h3><p>若列表中所有节点的逻辑次序和其和其大小次序完全一致，则被称为有序列表。</p>
<h3 id="插入排序（insertionsort）P79"><a href="#插入排序（insertionsort）P79" class="headerlink" title="插入排序（insertionsort）P79"></a>插入排序（insertionsort）<em>P79</em></h3><p>插入排序适用于任何序列结构，他的算法的大致思路可以概括为，始终将序列切分为有序的前缀和无序的后缀，将后缀中的首元素，放入有序的前缀中。插入排序就跟打牌一样，你先摸一张起来，就是牌堆里面的无序的牌，但是手里的牌是有序的，你每摸出一张无序的牌，就是相当于从它的后缀里面取出一个元素出来，你手里的牌就是前置里面有序的排，把每张牌都插入到你那个手中牌的正确的位置中，这就是插入排序。</p>
<h3 id="选择排序（selectionsort）P80"><a href="#选择排序（selectionsort）P80" class="headerlink" title="选择排序（selectionsort）P80"></a>选择排序（selectionsort）<em>P80</em></h3><p>选择排序也适用于任何序列结构，他的算法的大致思路是也将训练分为无序的前缀和有序的后缀，在无序的前缀中选出最大的元素，放入后缀的开头。选择排序相当于相当于串手链，就是你手里面有一堆珠子放在一个盘子里面，然后你要用从大到小的顺序把那个珠子给串起来，你就在那一堆没有排序的前缀的中间选出一个最大的元素，然后放在那个绳子上面，在那个里面再选出最大的元素，然后再把它放在有序的后缀中，然后再选出前中最大的元素，再放入那个后缀中对应的位置。</p>
]]></content>
      <categories>
        <category>-学习</category>
      </categories>
      <tags>
        <tag>-data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>毛中特第十章（五）</title>
    <url>/2019/12/03/%E6%AF%9B%E4%B8%AD%E7%89%B9%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%885%EF%BC%89/</url>
    <content><![CDATA[<h1 id="“五位一体”总布局之生态文明"><a href="#“五位一体”总布局之生态文明" class="headerlink" title="“五位一体”总布局之生态文明"></a>“五位一体”总布局之生态文明</h1><p>这一章的逻辑性不太强，随缘记吧。</p>
<a id="more"></a>
<h2 id="坚持人与自然和谐共生"><a href="#坚持人与自然和谐共生" class="headerlink" title="坚持人与自然和谐共生"></a>坚持人与自然和谐共生</h2><p>生态文明的核心是坚持人与自然和谐共生，树立尊重自然，顺应自然，保护自然的生态文明理念。</p>
<h2 id="新时代推进生态文明建设必须坚持的原则"><a href="#新时代推进生态文明建设必须坚持的原则" class="headerlink" title="新时代推进生态文明建设必须坚持的原则"></a>新时代推进生态文明建设必须坚持的原则</h2><h3 id="现实与自然和谐共生"><a href="#现实与自然和谐共生" class="headerlink" title="现实与自然和谐共生"></a>现实与自然和谐共生</h3><h3 id="清绿水青山就是金山银山"><a href="#清绿水青山就是金山银山" class="headerlink" title="清绿水青山就是金山银山"></a>清绿水青山就是金山银山</h3><h3 id="良好的生态环境是最普惠的民生福祉"><a href="#良好的生态环境是最普惠的民生福祉" class="headerlink" title="良好的生态环境是最普惠的民生福祉"></a>良好的生态环境是最普惠的民生福祉</h3><h3 id="山水林田湖草是生命共同体"><a href="#山水林田湖草是生命共同体" class="headerlink" title="山水林田湖草是生命共同体"></a>山水林田湖草是生命共同体</h3><h3 id="用最严格，制度最严密法制保护生态环境"><a href="#用最严格，制度最严密法制保护生态环境" class="headerlink" title="用最严格，制度最严密法制保护生态环境"></a>用最严格，制度最严密法制保护生态环境</h3><h3 id="共谋全球生态文明建设，深度参与全球环境治理"><a href="#共谋全球生态文明建设，深度参与全球环境治理" class="headerlink" title="共谋全球生态文明建设，深度参与全球环境治理"></a>共谋全球生态文明建设，深度参与全球环境治理</h3><h2 id="形成人与自然和谐发展的新格局"><a href="#形成人与自然和谐发展的新格局" class="headerlink" title="形成人与自然和谐发展的新格局"></a>形成人与自然和谐发展的新格局</h2><h2 id="生态文明体系"><a href="#生态文明体系" class="headerlink" title="生态文明体系"></a>生态文明体系</h2><p>包括生态文化体系，生态经济体系，目标责任体系，生态文明制度体系，生态安全体系。</p>
<h2 id="生态文明体制改革"><a href="#生态文明体制改革" class="headerlink" title="生态文明体制改革"></a>生态文明体制改革</h2><p>1推动形成绿色发展方式和生活方式。<br>2着力解决突出的环境问题<br>3加大生态系统保护力度<br>4生态环境监管体制的改革<br>什么意思呢？就是要绿色的发展方式和生活方式就是，在发展的过程中的那些方式，比如企业工厂，那个生产的方式要进行改变，还有人们的消费习惯也要发生改变。着力解决突出的环境问题，就是比如现在很严重的雾霾问题。加大环境保护力度，就是完成生态保护红线永久基本农田，城镇开发边界三条控制线划定工作，这个呢就是国家政策，在对于环境保护上面的一些着力点，它通过这三条边界的划定来与通过与土地相关的一些政策，来保护环境，第4个就是，改革生态监管体制，把机构建立起来，然后强力执行重惩治。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-政治</tag>
      </tags>
  </entry>
  <entry>
    <title>毛中特第十章（四）</title>
    <url>/2019/12/03/%E6%AF%9B%E4%B8%AD%E7%89%B9%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%884%EF%BC%89/</url>
    <content><![CDATA[<h1 id="“五位一体”总布局之社会建设"><a href="#“五位一体”总布局之社会建设" class="headerlink" title="“五位一体”总布局之社会建设"></a>“五位一体”总布局之社会建设</h1><a id="more"></a>
<h2 id="民生水平"><a href="#民生水平" class="headerlink" title="民生水平"></a>民生水平</h2><p>保障和改善民生是推动社会发展的根本目的<br>第1个是发展教育事业<br>第2个是就业质量和人民收入水平<br>第3是社会保障制度<br>第4式，脱贫攻坚战<br>第五是健康中国战略保持人民健康<br>注意第2个和第4个的区别，提高人民收入水平，是指平均的和整体的水平提高，脱贫攻坚战是指贫困人口。其实他们之间可能也还是有逻辑上面的串联吧，比如说你教育，教育搞得好，全民文化水平很高的话，就业质量就会提高，就业质量提高了，收入水平也就会提高，全体的收入水平提高之后就会，像北欧和北欧那边社会社会保障制度会很完善，然后再就是脱贫消除消除贫富差距之间的问题，最后就是，人民的身体健康很重要。</p>
<h2 id="社会治理"><a href="#社会治理" class="headerlink" title="社会治理"></a>社会治理</h2><p>社会治理是非常重要的。<br>在十九大中提出了社会建设的目标要求，就是到2035年blah blahblahblah，然后到本世纪中叶又布啦布啦布啦布啦。<br>那么建设社会治理的建设又有哪些具体措施来实施呢？<br>第1个是要创新，创新社会治理的体制<br>第二是改进社会治理的方式<br>第三是加强预防和化解社会矛盾机制建设<br>第四是加强社会心理服务体系体系建设</p>
<h2 id="国家安全观"><a href="#国家安全观" class="headerlink" title="国家安全观"></a>国家安全观</h2><p>国家安全观就是以人民安全为宗旨，以政治安全为根本，以国家利益至上为准则。<br>为什么要坚持国家安全观呢？国家安全观的必要性，第一是，做到居安思危，是我党治理国家的一个重要原则，第二是发展使安全的基础，安全是发展的保障，只有在安全的情况下，我国才能平稳健康的发展。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-政治</tag>
      </tags>
  </entry>
  <entry>
    <title>毛中特第十章（三）</title>
    <url>/2019/12/03/%E6%AF%9B%E4%B8%AD%E7%89%B9%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<h1 id="“五位一体”总布局之文化建设"><a href="#“五位一体”总布局之文化建设" class="headerlink" title="“五位一体”总布局之文化建设"></a>“五位一体”总布局之文化建设</h1><a id="more"></a>
<h2 id="牢牢掌握意识形态工作领导权"><a href="#牢牢掌握意识形态工作领导权" class="headerlink" title="牢牢掌握意识形态工作领导权"></a>牢牢掌握意识形态工作领导权</h2><p>意识形态工作领导权是非常重要的，因为它决定了我们的旗帜道路和国家政治安全。上层建筑其实是统治阶级的上层建筑。怎么坚定坚定意识形态领导权呢？就是要坚持马克思主义指导地位，构建中国特色社会主义科学，坚持正确的舆论导向，营造良好的网络环境，落实意识形态责任制。</p>
<h2 id="培育和践行社会主义核心价值观"><a href="#培育和践行社会主义核心价值观" class="headerlink" title="培育和践行社会主义核心价值观"></a>培育和践行社会主义核心价值观</h2><p>核心价值观是一个民族的精神纽带，是思想道德基础。<br>社会主义核心价值观：富强，民主，文明，和谐，自由，平等，公正，法治，爱国，敬业，诚信，友善，这个就不再赘述了，都很熟悉了。<br>社会主义核心价值<strong>体系</strong>的基本内容有4个方面，第1个是马克思主义指导思想，第2个是中国特色社会主义共同理想，第3个是以爱国主义为核心的民族精神和以改革创新为核心的时代精神，第4个是社会主义荣辱观。<br>注意社会主义核心价值观与社会主义核心价值体系之间的关系。</p>
<h2 id="坚定文化，自信建设社会主义文化强国"><a href="#坚定文化，自信建设社会主义文化强国" class="headerlink" title="坚定文化，自信建设社会主义文化强国"></a>坚定文化，自信建设社会主义文化强国</h2><p>1个是要有自信心，因为文化自信是非常重要的，其次我们是中国是一个，有着很悠久的和很优秀的传统文化的国家，我们要对这些传统文化进行创新性和创造性的一些改善和发展，以达到发展成为一个文化强国的目标。文化强国有三个衡量的指标，第1个是国民素质，第2个是文化产业的发展，第3个是国家的软实力，所以我们要提高文化产业的发展，还有提高国家文化。</p>
]]></content>
      <categories>
        <category>-master</category>
      </categories>
      <tags>
        <tag>-政治</tag>
      </tags>
  </entry>
  <entry>
    <title>毛中特第十章（二）</title>
    <url>/2019/12/03/%E6%AF%9B%E4%B8%AD%E7%89%B9%E7%AC%AC%E5%8D%81%E7%AB%A0%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<h1 id="“五位一体”总布局之政治建设"><a href="#“五位一体”总布局之政治建设" class="headerlink" title="“五位一体”总布局之政治建设"></a>“五位一体”总布局之政治建设</h1><p><img src="https://wx4.sinaimg.cn/mw690/6a29228bgy1g6y7zl0el5j20zf0zk1kx.jpg" alt="来啦2020"></p>
<a id="more"></a>
<h2 id="坚持中国特色社会主义政治发展道路"><a href="#坚持中国特色社会主义政治发展道路" class="headerlink" title="坚持中国特色社会主义政治发展道路"></a>坚持中国特色社会主义政治发展道路</h2><p>中国特色社会主义是必然结果，也是必然要求，中国特色社会主义包括三方面，一个是党的领导，一个是人民当家作主，还有一个是依法治国，三者要有机统一。人民当家作主是本质，党的领导是根本保证，依法治国是基本方式。<br>走中国特色社会主义政治发展道路必须坚持，正确的政治方向，也就是说，在外界都是资本主义的情况下，我们还能保持，和坚持自己的这条道路，让自己的目标和方向不会发生改变。<br>人民当家作主是社会主义民主政治的本质和核心，人民当家作主的基本内涵，第一是在国体和政体上面属于人民，第二是在法律制度题和体制机制上面属于人民，第三，是国家机关和公务员都是依靠人民的第四，法律法规和方针政策和人民相关地5，国家各方面事业和各方面工作都坚持以人民为中心。</p>
<h2 id="健全人民当家作主制度体系"><a href="#健全人民当家作主制度体系" class="headerlink" title="健全人民当家作主制度体系"></a>健全人民当家作主制度体系</h2><p>第1个是政治制度是人民代表大会制度，是我国的根本政治制度安排。<br>第2个是中国共产党的多党合作和政治协商制度，但是中国共产党的领导是，根本首要前提和根本保证，然后多党合作才是核心内容，就是说中国共产党的领导还是要排在第首位的位置，然后中国共产党与各民主党派的合作基本方针是，长期共存，相互监督，肝胆相照，荣辱与共。人民政协那是一个组织是一种机构。人民政协的主题是团结和民主，主要职能是政治协商，民主监督，参政议政。<br>第3个是民族之民族名民族区域自治制度。就是核心是让少数民族当家作主，但是，要维护国家统一领土完整。<br>第4个是基层群众自治制度。农村村民委员会、城市居民委员会、企业职工代表大会。<br>第5个是社会主义协商民主。协商民主是中国社会主义民主政治的特有形式和独特优势。</p>
<h2 id="巩固和发展爱国统一战线"><a href="#巩固和发展爱国统一战线" class="headerlink" title="巩固和发展爱国统一战线"></a>巩固和发展爱国统一战线</h2><p>第1个方面是各民主党派<br>第2个方面是民族方面<br>第3个方面是宗教方面<br>然后就是要牢牢把握大团结大联合的主题，做好统战工作。统一战线就是从毛泽东开始开始提出的一个思想政策，所以在共产党中间一直很很在意统一战线这一政治方面的因素，这是关系到人心的向背力量的对比是成败的关键因素。</p>
<h2 id="坚持“一国两制”，推进祖国统一"><a href="#坚持“一国两制”，推进祖国统一" class="headerlink" title="坚持“一国两制”，推进祖国统一"></a>坚持“一国两制”，推进祖国统一</h2><p>“一国两制”，“港人治港”，“澳人治澳”，高度自治。<br>从4个方面把握一国两制的问题，第1个是要准确把握一国和两制之间的关系，一国是两制的前提，第2是必须依照宪法和基本法办事，第3是要把发展作为第一要务，第4必须要维护稳定和谐的社会环境。<br>再就是台湾的问题。第1个是一起推进中华民族伟大复兴，第2个是探索一国两制的制度，第3个是，坚持一个中国原则，第4个是融合发展，第5个是心灵契合。</p>
]]></content>
      <tags>
        <tag>-政治</tag>
      </tags>
  </entry>
  <entry>
    <title>毛中特第十章</title>
    <url>/2019/12/03/%E6%AF%9B%E4%B8%AD%E7%89%B9%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="“五位一体”总体布局经济篇"><a href="#“五位一体”总体布局经济篇" class="headerlink" title="“五位一体”总体布局经济篇"></a>“五位一体”总体布局经济篇</h1><a id="more"></a>
<p>好，我们再来复习一下8个明确中的第2个是，社会矛盾，这个前面已经说过了，我们就不说了，第3个是，明确中国特色社会的事业，总体布局是5位一体，战略布局是4个全面。<br>什么是5位一体的？5位一体在前面背过，就是2020年到2035年之间两步走第1步的，经济建设，政治建设，文化建设，社会建设和生态文明建设的5位一体。五位一体的内容很多，这里只讲经济部分。</p>
<h2 id="贯彻新发展理念"><a href="#贯彻新发展理念" class="headerlink" title="贯彻新发展理念"></a>贯彻新发展理念</h2><p>新发展理念又有5个词叫做创新，协调，绿色，开放，共享。</p>
<h3 id="创新"><a href="#创新" class="headerlink" title="创新"></a>创新</h3><p>注重的是解决发展动力的问题，就是，你要怎么样才能促进发展，你就肯定要创新，你创新的才能让这个世界和这个社会发展起来。</p>
<h3 id="协调"><a href="#协调" class="headerlink" title="协调"></a>协调</h3><p>注重的是解决发展不平衡的问题，因为之前讲到，我国社会主义的主要矛盾已经转变成了发展不平衡不充分的问题，所以我们要协调的发展就是要充分又平衡的发展。</p>
<h3 id="绿色"><a href="#绿色" class="headerlink" title="绿色"></a>绿色</h3><p>就是人与环境自然一些之间的问题，环保之间的问题。</p>
<h3 id="开放"><a href="#开放" class="headerlink" title="开放"></a>开放</h3><p>就是解决内外联动的问题，就是不要，不要太封闭，不要闭关锁国，在把自己关在一个地方搞自己的事情，中国之前不是吃了很多闭关锁国的亏吗？</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>是，解决社会公平正义的问题，就是，嗯，就是，不仅要把蛋糕做大，还要关注蛋糕怎么分的问题。</p>
<h2 id="深化供给侧结构性改革"><a href="#深化供给侧结构性改革" class="headerlink" title="深化供给侧结构性改革"></a>深化供给侧结构性改革</h2><h3 id="深化供给侧改革的必要性"><a href="#深化供给侧改革的必要性" class="headerlink" title="深化供给侧改革的必要性"></a>深化供给侧改革的必要性</h3><p>经济发展面临的问题有两个方面，一个是供给方，一个是需求方，但是我国的经济问题的主要方面还是处在供给方上面的问题，这是我国的现状。<br>所以我们要对供给方进行结构化的改革，<br>结构化的改革怎么改呢？就是要就是要让供给能够更好的满足人民，日益增长的美好生活的需要，<br>解决方法就是比如解放和发展社会生产力，用改革的办法进行结构化的调整，减少无效和低端的供给，扩大和有效和中高端的供给，提高全要素生产率等等等等。</p>
<h3 id="供给侧结构性改革的主要任务"><a href="#供给侧结构性改革的主要任务" class="headerlink" title="供给侧结构性改革的主要任务"></a>供给侧结构性改革的主要任务</h3><p>第1个是，全面提升制造业和实体业的发展。<br>第2个是深化要素市场配置改革，就是让中国的制造业从以价格取胜转化变成以质量取胜，<br>第三是，对人力资源的培养要加大。<br>第四是维持推进三去一降一补。去产能，去库存，去杠杆，降成本，补短板。</p>
<h2 id="建设现代化经济体系的主要任务"><a href="#建设现代化经济体系的主要任务" class="headerlink" title="建设现代化经济体系的主要任务"></a>建设现代化经济体系的主要任务</h2><h2 id="新时代经济发展的基本特征"><a href="#新时代经济发展的基本特征" class="headerlink" title="新时代经济发展的基本特征"></a>新时代经济发展的基本特征</h2><p>是由高速发展向高质量发展转变。</p>
<h2 id="推动高质量发展的原因"><a href="#推动高质量发展的原因" class="headerlink" title="推动高质量发展的原因"></a>推动高质量发展的原因</h2><p>第1个是，为了保持经济的健康的发展，第2个是我国社会基本矛盾已经发生了变化，第3个是经济发展的必然规律。</p>
<h2 id="现代化经济体系的科学内涵"><a href="#现代化经济体系的科学内涵" class="headerlink" title="现代化经济体系的科学内涵"></a>现代化经济体系的科学内涵</h2><p>也就是现代化经济体系的内容。6个体系，一个体制。</p>
<h2 id="建设现代化经济体系的主要任务-1"><a href="#建设现代化经济体系的主要任务-1" class="headerlink" title="建设现代化经济体系的主要任务"></a>建设现代化经济体系的主要任务</h2><p>1，以大力发展实体经济。<br>2，实施创新驱动驱动发展战略。<br>3，就是，第三就是实施乡村振兴战略，这里的乡村主要指的是农村，是农村农业现代化问题，乡村治理体系的一些问题。<br>4，推动城乡区域协调发展，这里的城乡，就是指北京之外的所有的一些小城市。注意第4个和第3个的区别，第3个是指农村，第4个是指，嗯，除大城市之外的一些小城市的一些发展，要平衡要均衡的问题。<br>5，是开放型经济，进行国际化的经济体系和经济形势<br>6，深化经济体制改革，也就是说，对社保啊，还有，产权啊，还有要素市场这方面进行进一步的改革。<br> 最后就是我国是公有制为主体，多种所有制经济共同发展的经济，基本经济制度，这是中国特色社会主义制度的重要组成部分，也就是说，虽然我们是社会主义，但是我们不全是公有制的经济形势，这就是所谓中国特色社会主义的含义，除此之外我们也不能抛弃民营经济，民营经济是我国经济的重要组成部分，我们还要大展大力发展民营民营经济。</p>
]]></content>
      <categories>
        <category>-考研</category>
      </categories>
      <tags>
        <tag>-政治 -毛中特</tag>
      </tags>
  </entry>
  <entry>
    <title>毛中特第九章</title>
    <url>/2019/12/03/%E6%AF%9B%E4%B8%AD%E7%89%B9%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="坚持和发展中国特色社会主义的总任务"><a href="#坚持和发展中国特色社会主义的总任务" class="headerlink" title="坚持和发展中国特色社会主义的总任务"></a>坚持和发展中国特色社会主义的总任务</h1><a id="more"></a>
<p>刚刚不是说了什么8个明确嘛，然后第一点就是明确的总任务，总任务分两个，一个是实现中华民族的伟大复兴，还一个是建设社会主义的现代化强国。</p>
<h2 id="中华民族的伟大复兴的中国梦"><a href="#中华民族的伟大复兴的中国梦" class="headerlink" title="中华民族的伟大复兴的中国梦"></a>中华民族的伟大复兴的中国梦</h2><p>中华民族的伟大复兴的另外一种说法就是，中国梦。</p>
<h3 id="中国梦的科学内涵"><a href="#中国梦的科学内涵" class="headerlink" title="中国梦的科学内涵"></a>中国梦的科学内涵</h3><p>第1个是，本质是，国家富强，民族振兴，人民幸福。<br>第2个是中国梦，归根到底说是根是人民的梦，人民是中国梦的主体，是中国梦的创造者和享有者。<br>第3个是，中国梦和全世界人民的梦想是相通的。</p>
<h3 id="奋力实现中国梦就是说"><a href="#奋力实现中国梦就是说" class="headerlink" title="奋力实现中国梦就是说"></a>奋力实现中国梦就是说</h3><p>想要实现中国梦要怎么做呢？<br>第1个就是，走中国道路，弘扬中国精神，凝聚中国力量，中国道路就是中国特色社会主义道路，中国精神就是爱国主义精神，中国中国力量就是各各民族民族大团结的意思。<br>第2个就是实干。有梦想，要实干才能实现。</p>
<h2 id="建设社会主义现代化强国"><a href="#建设社会主义现代化强国" class="headerlink" title="建设社会主义现代化强国"></a>建设社会主义现代化强国</h2><h3 id="怎么建社会主义现代化强国呢——两步走"><a href="#怎么建社会主义现代化强国呢——两步走" class="headerlink" title="怎么建社会主义现代化强国呢——两步走"></a>怎么建社会主义现代化强国呢——两步走</h3><p>第1个阶段就是从2020年到2035年，基本实现社会主义现代化。所以他为什么要唱歌，唱我和2035有个约呢？就是要基本形成社会主义现代化。<br>第2个阶段就是从2035年往后到2020世纪中叶，再奋斗15年，把我国建设成富强民主文明和谐美丽社会主义现代化强国。</p>
<h3 id="那么这个两步走有什么特点呢？"><a href="#那么这个两步走有什么特点呢？" class="headerlink" title="那么这个两步走有什么特点呢？"></a>那么这个两步走有什么特点呢？</h3><p>第1个它提前了15年，虽然我也不知道是什么，提钱的时候反正就提前了15年。<br>第2个就是她把美丽加在了中间。<br>第3个就是他没有再提出什么类似于GDP会翻番的一些内容。</p>
<h3 id="他具体是怎么安排的呢？"><a href="#他具体是怎么安排的呢？" class="headerlink" title="他具体是怎么安排的呢？"></a>他具体是怎么安排的呢？</h3><p>第1步里面呢，就是说要搞经济建设，政治建设，文化建设，社会建设和生态文明建设的5位一体的要求。<br>第2部里面呢，就是要提升物质文明，政治文明，精神文明，社会文明，生态文明。建成富强民主文明和谐美丽的社会主义现代化强国。</p>
]]></content>
      <categories>
        <category>-考研</category>
      </categories>
      <tags>
        <tag>-政治</tag>
      </tags>
  </entry>
  <entry>
    <title>毛中特第八章</title>
    <url>/2019/12/03/%E6%AF%9B%E4%B8%AD%E7%89%B9%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="中国特色社会主义进入新时代"><a href="#中国特色社会主义进入新时代" class="headerlink" title="中国特色社会主义进入新时代"></a>中国特色社会主义进入新时代</h1><p>不能放弃，搏一搏单车变摩托。我不指望能考400过初试，让我考个350我就满足了。</p>
<a id="more"></a>
<h2 id="依据"><a href="#依据" class="headerlink" title="依据"></a>依据</h2><p>新的奋斗目标，新的发展阶段，社会主要矛盾，国际地位都发生了变化。</p>
<h2 id="内涵"><a href="#内涵" class="headerlink" title="内涵"></a>内涵</h2><p>是这是一个转折点，承前启后的，继往开来是决胜全面建成小康社会，开始全面建成社会主义现代化强国的时代<br>是实现人民共同富裕，中华民族伟大复兴的时代<br>是我国日益走近，世界舞台中央的时代<br>其实和上面的依据是对应的，新的阶段，新的目标，国际地位</p>
<h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>就是说从中国的角度来看，是一个飞跃。从科学社会角度的，上面来看是一个飞跃。从全人类的文明历史上来看也是一个进步。</p>
<h1 id="我国社会主要矛盾的变化"><a href="#我国社会主要矛盾的变化" class="headerlink" title="我国社会主要矛盾的变化"></a>我国社会主要矛盾的变化</h1><h2 id="依据-1"><a href="#依据-1" class="headerlink" title="依据"></a>依据</h2><p>社会主要矛盾，已经转化为人民日益增长的美好生活，需要和不平衡不，不平衡不充分的发展之间的矛盾，嗯，就是，我国的社会生产力已经得到了很大的提高，人们对社会的需求已经不再只是停留在物质上面的需求而逐渐提高到了一个精神层次上面的需求，影响这些需要的主要的因素是，发展的不平衡和不充分。</p>
<h2 id="我国社会主要矛盾的变化没有改变我过的历史阶段"><a href="#我国社会主要矛盾的变化没有改变我过的历史阶段" class="headerlink" title="我国社会主要矛盾的变化没有改变我过的历史阶段"></a>我国社会主要矛盾的变化没有改变我过的历史阶段</h2><p>就是，我国社会主要矛盾的变化虽然是很重要的，是一个关系全局的，并且是历史性的变化，但是我国的基本国情还是社会主义初级阶段，然后我国的国际地位也还是最大的发展中国家。</p>
<h1 id="习近平新时代中国特色社会主义思想的主要内容"><a href="#习近平新时代中国特色社会主义思想的主要内容" class="headerlink" title="习近平新时代中国特色社会主义思想的主要内容"></a>习近平新时代中国特色社会主义思想的主要内容</h1><h2 id="习近平新时代中国特色社会主义思想的内涵"><a href="#习近平新时代中国特色社会主义思想的内涵" class="headerlink" title="习近平新时代中国特色社会主义思想的内涵"></a>习近平新时代中国特色社会主义思想的内涵</h2><p>8个明确</p>
<h3 id="总任务是实现社会主义现代化，和中华民族伟大复兴矛盾"><a href="#总任务是实现社会主义现代化，和中华民族伟大复兴矛盾" class="headerlink" title="总任务是实现社会主义现代化，和中华民族伟大复兴矛盾"></a>总任务是实现社会主义现代化，和中华民族伟大复兴矛盾</h3><h3 id="矛盾已经说过了"><a href="#矛盾已经说过了" class="headerlink" title="矛盾已经说过了"></a>矛盾已经说过了</h3><h3 id="总体布局是5位一体-4个全面"><a href="#总体布局是5位一体-4个全面" class="headerlink" title="总体布局是5位一体  4个全面"></a>总体布局是5位一体  4个全面</h3><h3 id="总目标是全面深化改革"><a href="#总目标是全面深化改革" class="headerlink" title="总目标是全面深化改革"></a>总目标是全面深化改革</h3><h3 id="总目标是全面推进依法治国，"><a href="#总目标是全面推进依法治国，" class="headerlink" title="总目标是全面推进依法治国，"></a>总目标是全面推进依法治国，</h3><h3 id="建强军目标"><a href="#建强军目标" class="headerlink" title="建强军目标"></a>建强军目标</h3><h3 id="特色大国外交"><a href="#特色大国外交" class="headerlink" title="特色大国外交"></a>特色大国外交</h3><h3 id="最本质是中国共产党的领导。"><a href="#最本质是中国共产党的领导。" class="headerlink" title="最本质是中国共产党的领导。"></a>最本质是中国共产党的领导。</h3><h2 id="坚持和发展中国特色社会主义的基本方略"><a href="#坚持和发展中国特色社会主义的基本方略" class="headerlink" title="坚持和发展中国特色社会主义的基本方略"></a>坚持和发展中国特色社会主义的基本方略</h2><p>14个坚持</p>
<h2 id="历史地位"><a href="#历史地位" class="headerlink" title="历史地位"></a>历史地位</h2><p>一是对马克思主义中国化上面来说，它是最新的成果<br>第二是，新时代的精神旗帜，是国家政治生活和社会生活的根本指针，就是对我国的党章和宪法有影响<br>第三是，是实现中华民族伟大复兴的行动指南，就是。就是在实现中国的一些，嗯目标上面的指导。</p>
]]></content>
      <categories>
        <category>-考研</category>
      </categories>
      <tags>
        <tag>-政治</tag>
      </tags>
  </entry>
  <entry>
    <title>如何记忆大段文字并在考试时信手引用？</title>
    <url>/2019/12/03/demo/</url>
    <content><![CDATA[<p><img src="https://wx3.sinaimg.cn/mw690/005Nep6ygy1g8k0p5s3y9j32wv1y41kz.jpg" alt></p>
<a id="more"></a>
<p><strong>记忆的一个重要前提：考试要求是对观点能够信手拈来，而论据和观点本身化为己用，并不是一字不差地誊写在卷面上。</strong></p>
<h4 id="不要直接背书上的叙述性文字，要通过自己的语言加工，机械重复并不能加强记忆"><a href="#不要直接背书上的叙述性文字，要通过自己的语言加工，机械重复并不能加强记忆" class="headerlink" title="不要直接背书上的叙述性文字，要通过自己的语言加工，机械重复并不能加强记忆"></a>不要直接背书上的叙述性文字，要通过自己的语言加工，机械重复并不能加强记忆</h4><h4 id="如何进行精细加工？"><a href="#如何进行精细加工？" class="headerlink" title="如何进行精细加工？"></a>如何进行精细加工？</h4><p>记忆书本原有的关键词、知识点等“点”信息，而后自己去连“点”成“线”，把这一块的“点”信息串成有逻辑的内容。<br>怎么联系？记住关键词和知识点之后，记关系：并列？因果？时间？空间？人物？然后合上书本，用自己的逻辑语言系统把关键词串起来。</p>
<blockquote>
<p>《自控力》关于睡眠的表述：<strong>长期睡眠不足</strong>让你更容易感到<strong>压力</strong>、萌生欲望、受到诱惑。还让你很难控制<strong>情绪</strong>、集中<strong>注意力</strong>。<br>关键词已经标出，关系是因果。串起来就是：长期睡眠不足的危害有：压力大、欲望多、情绪暴躁、注意力分散。<br>还可以通过讯飞语记，在无人处出声进行“串起来”，它会把声音转化成文字，然后自行对文字进行修改；之后复习，可直接看自己的文字表述，内容更熟悉，记忆更牢靠。</p>
</blockquote>
<h4 id="先“记少”"><a href="#先“记少”" class="headerlink" title="先“记少”"></a>先“记少”</h4><p>在对书本的第一遍、第二遍记忆时，记少能提高记忆内容的覆盖面，当考试时基本上能够把观点都罗列出来。</p>
<h4 id="后“记多”"><a href="#后“记多”" class="headerlink" title="后“记多”"></a>后“记多”</h4><p>然后开始由少记多，这一过程放在后面几遍的复习过程中。比如某一段重要的文字，你之前记了两个核心观点，在第三遍复习的时候，核心观点已经成为了你的“已有的知识经验”，这时候剩下“相对陌生”的知识与之前记住的知识点有千丝万缕的联系，与已有的知识经验结合记忆，会更高效。</p>
<h4 id="无论时间的多寡，都先记“少”，但如果最后只记住了少，那也很能打"><a href="#无论时间的多寡，都先记“少”，但如果最后只记住了少，那也很能打" class="headerlink" title="无论时间的多寡，都先记“少”，但如果最后只记住了少，那也很能打"></a>无论时间的多寡，都先记“少”，但如果最后只记住了少，那也很能打</h4><p>把其他模块与它相关的知识，往所知的“少”上靠，往深里论述。<br>重要的是答题过程，所体现的思路和思考能力，而非背书天分。</p>
]]></content>
  </entry>
  <entry>
    <title>《数据结构》关键词索引整理（二）</title>
    <url>/2019/12/03/Key-Words-in-Data-Structure2/</url>
    <content><![CDATA[<blockquote>
<p>“  你是我新奇的无尽宝藏<br>    是拂去所有枝叶的百分百现实  ”<br>/ 高村光太郎</p>
</blockquote>
<a id="more"></a>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p><img src="https://wx1.sinaimg.cn/mw690/532c5244gy1g95ux4ffw5j20u01407ql.jpg" alt></p>
<h3 id="序列（sequence）、向量（vector）、列表（list）、秩（rank）、位置（position）P28"><a href="#序列（sequence）、向量（vector）、列表（list）、秩（rank）、位置（position）P28" class="headerlink" title="序列（sequence）、向量（vector）、列表（list）、秩（rank）、位置（position）P28"></a>序列（sequence）、向量（vector）、列表（list）、秩（rank）、位置（position）<em>P28</em></h3><p>最基本的线性结构被称为序列，根据数据项的逻辑次序和物理存贮次序是否吻合可以讲其分为向量和列表。在向量中数据项的逻辑次序和物理储存地址的次序相对应，此时的逻辑次序被称为秩。在列表中数据项的逻辑次序和物理存储地址的次序不一定相对应，其用间接定址的方式通过封装后的位置相互引用。</p>
<h3 id="数组（array）P28"><a href="#数组（array）P28" class="headerlink" title="数组（array）P28"></a>数组（array）<em>P28</em></h3><p>若集合S中有n个元素，且元素之间存在着一定的次序，则可以把该数组存储在以A[]为首起始地址的一段连续的存储空间中，并且把他们统称为数组，通常以A[]作为该数组的标识。</p>
<h3 id="前驱（predecessor）、后继（successor）、直接前驱（immediate-predecessor）、直接后继（immediate-predecessor）、前缀（prefix）、后缀（sffix）P28"><a href="#前驱（predecessor）、后继（successor）、直接前驱（immediate-predecessor）、直接后继（immediate-predecessor）、前缀（prefix）、后缀（sffix）P28" class="headerlink" title="前驱（predecessor）、后继（successor）、直接前驱（immediate predecessor）、直接后继（immediate predecessor）、前缀（prefix）、后缀（sffix）P28"></a>前驱（predecessor）、后继（successor）、直接前驱（immediate predecessor）、直接后继（immediate predecessor）、前缀（prefix）、后缀（sffix）<em>P28</em></h3><p>对于任何0&lt;=i&lt;j&lt;=n，A[i]都是A[j]前驱。A[j]都是A[i]的后期。特别的，对于任何i&gt;=1，A[i-1]称作A[i]的直接前驱，对任何i&lt;=n-2，A[i+1]称作A [i]的直接后继。任意元素的所有前驱统称为该元素的前缀，所有后继统称为该元素的后缀。也就是说前驱是指单个元素，后继也是指单个元素，在他前面就是他的前驱在他后面就是他的后继，然后在他前面一个的叫做直接前驱，在他后面一个的叫做直接后继，它的前驱构成的集合叫做前缀，后继构成的集合叫做后缀。</p>
<h3 id="线性数组（liner-array）P28"><a href="#线性数组（liner-array）P28" class="headerlink" title="线性数组（liner array）P28"></a>线性数组（liner array）<em>P28</em></h3><p>如果数组A[]的起始地址为A<br>，s为每个元素所占的空间大小，则元素A[i]的物理地址可以表示为A+i*s，因为元素的存储物理存储地址和它的下标之间存在这种线性关系，所以，被称为线性数组。</p>
<h3 id="向量（vector）基于线性数组（集合）的定义P29"><a href="#向量（vector）基于线性数组（集合）的定义P29" class="headerlink" title="向量（vector）基于线性数组（集合）的定义P29"></a>向量（vector）基于线性数组（集合）的定义<em>P29</em></h3><p>向量是线性数组的一种抽象和泛化，它是由具有线性关系的元素构成的集合，其中元素分别有秩来区分。<br>这几个概念之间的关系就是先引出数组的概念，数组的概念的定义是元素之间有次序关系的集合，放在一个有起始位置的连续的物理存储空间中这样来定义的。然后，再定义的是线性数组，就是解释了为什么数组又被称为线性数组，是因为数组的下标和他的物理存储空间之间存在一种线性的关系。再就是对向量的定，借助线性数组，说是对线性数组的一种抽象和泛化。因为数组本身也是一种集合，所以说在向量的定义中，也说它是一种集合，也说元素之间通过秩来相互区分。</p>
<h3 id="秩（rank）基于前驱的定义P29"><a href="#秩（rank）基于前驱的定义P29" class="headerlink" title="秩（rank）基于前驱的定义P29"></a>秩（rank）基于前驱的定义<em>P29</em></h3><p>各个元素的秩互异，且均为[0,n)之间的整数，若元素一的前区有r个则起秩就是r。</p>
<h3 id="寻秩访问（call-by-rank）P29"><a href="#寻秩访问（call-by-rank）P29" class="headerlink" title="寻秩访问（call-by-rank）P29"></a>寻秩访问（call-by-rank）<em>P29</em></h3><p>反过来通过而亦可获得e=Vr，这是向量特有的元素访问方式，称作寻秩访问访问。就是通过r来访问向量中的元素。</p>
<h3 id="构造函数（constructor）、初始化（initialization）P32"><a href="#构造函数（constructor）、初始化（initialization）P32" class="headerlink" title="构造函数（constructor）、初始化（initialization）P32"></a>构造函数（constructor）、初始化（initialization）<em>P32</em></h3><p>向量也是一种类，类在初始化为对象时，与所有对象一样向量在使用时也需要构造函数，对其进行初始化。</p>
<h3 id="析构函数（destructor）、清理（cleanup）P33"><a href="#析构函数（destructor）、清理（cleanup）P33" class="headerlink" title="析构函数（destructor）、清理（cleanup）P33"></a>析构函数（destructor）、清理（cleanup）<em>P33</em></h3><p>与所有对象一样，向量在不被需要的时候，也要调用构造析构函数对其进行清理，已释放被其占有的系统资源。</p>
<h3 id="上溢（overflow）P33"><a href="#上溢（overflow）P33" class="headerlink" title="上溢（overflow）P33"></a>上溢（overflow）<em>P33</em></h3><p>容量固定不变会导致无法加入更多的元素</p>
<h3 id="装填因子（loadfactor）P33"><a href="#装填因子（loadfactor）P33" class="headerlink" title="装填因子（loadfactor）P33"></a>装填因子（loadfactor）<em>P33</em></h3><p>向量实际规模（size）以及内部数组容量（capacity）的比值，称作装填因子，是衡量空间利用率的重要指标。扩充向量的原理是开辟一个新的向量空间，将原有的向量空间复制进去，且每次新扩充的向量空间是原来的两倍。</p>
<h3 id="野指针（wild-point）P34"><a href="#野指针（wild-point）P34" class="headerlink" title="野指针（wild point）P34"></a>野指针（wild point）<em>P34</em></h3><p>用数组来实现相应复制，空间扩充的时候新的向量，新的数组的指针与原来数组的指针是没有直接的关系的，这样原来指向原来数组的指针失效，变成了野指针。</p>
<h3 id="分摊运行时间（amortized-running-time）P35"><a href="#分摊运行时间（amortized-running-time）P35" class="headerlink" title="分摊运行时间（amortized running time）P35"></a>分摊运行时间（amortized running time）<em>P35</em></h3><p>可扩充向量的足够多次连续操作的时间分摊至每一次操作，如此平摊得到每单次操作的时间叫做分摊操作，分摊运行时间。平均运行时间是乘上概率的，是加权的平均时间。</p>
<h3 id="下溢（underflow-P36"><a href="#下溢（underflow-P36" class="headerlink" title="下溢（underflow)P36"></a>下溢（underflow)<em>P36</em></h3><p>在一系列操作中，若删除的次数远远大于插入的操作，这个时候，装填因子的数值可能会小于远远小于100%，甚至很接近于0，此时我们就称，数组发生了下溢。</p>
<h3 id="无序向量-unsorted-vector-P39"><a href="#无序向量-unsorted-vector-P39" class="headerlink" title="无序向量(unsorted vector)P39"></a>无序向量(unsorted vector)<em>P39</em></h3><p>仅支持对比（==、!=）而不支持比较的能量，被称为无序向量。</p>
<h3 id="顺序查找-sequential-search-P39"><a href="#顺序查找-sequential-search-P39" class="headerlink" title="顺序查找(sequential search)P39"></a>顺序查找(sequential search)<em>P39</em></h3><p>从元素末尾出发，逐一取出各个元素，并与目标元素进行比对，直到发现与之相等，或者将所有元素都比对之后，仍未发现与之相等，这种逐个对比，查找的方式被称为被称为顺序查找。<br>注意比较和对比的区别</p>
<h3 id="输入敏感算法-input-sensitive-P39"><a href="#输入敏感算法-input-sensitive-P39" class="headerlink" title="输入敏感算法(input sensitive)P39"></a>输入敏感算法(input sensitive)<em>P39</em></h3><p>规模相同，内部组成不同，渐进运算时间却有着本质的区别，这种算这种算法被称为输入敏感算法。</p>
<h3 id="错误（error）、意外-expection-P42"><a href="#错误（error）、意外-expection-P42" class="headerlink" title="错误（error）、意外(expection)P42"></a>错误（error）、意外(expection)<em>P42</em></h3><p>输入的参数超过接口范围的这类问题属于经典的错误或者意外，除了基于除此之外还要通过更加周全的设计来解决这个问题。</p>
<h3 id="二分查找法-binary-search-P49"><a href="#二分查找法-binary-search-P49" class="headerlink" title="二分查找法(binary search)P49"></a>二分查找法(binary search)<em>P49</em></h3><p>有序向量中间的元素，作为目标元素的试探对象，以最坏的情况来看，这个解决方法是最优的，因为。无论朝哪个迭代后无论朝哪个方向深入，其问题的规模都将缩小一半，这一策略被称为二分查找查找法。</p>
<h3 id="在线算法和离线算法-offline-algorithm-online-algorithm-P57"><a href="#在线算法和离线算法-offline-algorithm-online-algorithm-P57" class="headerlink" title="在线算法和离线算法(offline algorithm)(online algorithm)P57"></a>在线算法和离线算法(offline algorithm)(online algorithm)<em>P57</em></h3><p>根据输入形式的不同，排序算法可以分为在线算法和离线算法，离线排序是指在待排数据以批处理的方式整体给出。而在线算法是比如网络计算中，待排序的数据要实时生成，算法已经开始，待排的数据才传给算法。</p>
<h3 id="复杂下界-lower-bound）P58"><a href="#复杂下界-lower-bound）P58" class="headerlink" title="复杂下界(lower bound）P58"></a>复杂下界(lower bound）<em>P58</em></h3><p>一般在最坏情况下，得最低计算成本，即为该问题的复杂下界，一个问题，一旦在最坏的情况下达到这个下界，那么也意味着这已经是该问题的最坏情况下的最优解。</p>
<h3 id="比较树（comparison-tree）P58"><a href="#比较树（comparison-tree）P58" class="headerlink" title="比较树（comparison tree）P58"></a>比较树（comparison tree）<em>P58</em></h3><p>内部的每一个节点都对应的是一次比较。左右分支对应的是比较的两种结果，和他下一步将要执行的方向。叶子节点（或叶子节点到根节点的路径）表示的是最终的输出和算法执行的过程，反过来，算法的每一运行过程，都对应于从根到某一叶子节点的路径。</p>
<h3 id="基于比较式的算法CBA算法（comparison-based-algorithm）P58"><a href="#基于比较式的算法CBA算法（comparison-based-algorithm）P58" class="headerlink" title="基于比较式的算法CBA算法（comparison-based algorithm）P58"></a>基于比较式的算法CBA算法（comparison-based algorithm）<em>P58</em></h3><p>无论什么算法，只要他的分支取决于变量或常量的比较结果，那么它的所有的可能的执行过程就可以用比较树来表示，这就是所谓的基于比较式算法，简称CBA式算法。</p>
<h3 id="排序算法的稳定性（unstable-algorithm）P61"><a href="#排序算法的稳定性（unstable-algorithm）P61" class="headerlink" title="排序算法的稳定性（unstable algorithm）P61"></a>排序算法的稳定性（unstable algorithm）<em>P61</em></h3><p>排序算法的稳定性是对排序算法更为细致的要求，简而言之就相同元素之间的相对位置在排序前后保持不变，反之，则是不稳定的排序算法。</p>
]]></content>
      <categories>
        <category>-学习</category>
      </categories>
      <tags>
        <tag>-数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>《数据结构》关键词索引整理（一）</title>
    <url>/2019/12/02/Key-Words-in-Data-Structure/</url>
    <content><![CDATA[<p>既然数据结构会考这种送分题那我就不客气了👌</p>
<a id="more"></a>
<h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="计算科学-computer-science-P2"><a href="#计算科学-computer-science-P2" class="headerlink" title="计算科学(computer science) P2"></a>计算科学(computer science) <em>P2</em></h3><p>科学计算的核心在于研究计算方法与过程，而不仅仅是作为计算工具本身。因此E.Digkstra更倾向于将这门学科称为计算科学(computing science)</p>
<h3 id="排序-sorting-P4"><a href="#排序-sorting-P4" class="headerlink" title="排序(sorting) P4"></a>排序(sorting) <em>P4</em></h3><p>将n个整数按通常的大小次序排成一个非降序列。这类操作统称为排序。</p>
<h3 id="有穷性-finiteness-P6"><a href="#有穷性-finiteness-P6" class="headerlink" title="有穷性(finiteness)P6"></a>有穷性(finiteness)<em>P6</em></h3><p>任意算法都应该在执行有限次基本操作之后终止并给出输出，此即所谓算法的有穷性。</p>
<h3 id="正确性（correctness）P6"><a href="#正确性（correctness）P6" class="headerlink" title="正确性（correctness）P6"></a>正确性（correctness）<em>P6</em></h3><p>所给的输出还应该能够符合由问题本身在事先确定的条件，此即所谓算法的正确性。</p>
<h3 id="退化（degeneracy）P7"><a href="#退化（degeneracy）P7" class="headerlink" title="退化（degeneracy）P7"></a>退化（degeneracy）<em>P7</em></h3><p>除一般情况外，实用的算法还应该能够处理各种极端的输入实例。</p>
<h3 id="鲁棒性（robustness）P7"><a href="#鲁棒性（robustness）P7" class="headerlink" title="鲁棒性（robustness）P7"></a>鲁棒性（robustness）<em>P7</em></h3><p>要求能够尽可能充分地应对退化的情况。</p>
<h3 id="可计算性（computability）P7"><a href="#可计算性（computability）P7" class="headerlink" title="可计算性（computability）P7"></a>可计算性（computability）<em>P7</em></h3><p>就大量应用问题而言，根本就不可能设计出必然终止的算法，从这个意义讲，它们都属于不可解的问题。</p>
<h3 id="难解性（intractability）P8"><a href="#难解性（intractability）P8" class="headerlink" title="难解性（intractability）P8"></a>难解性（intractability）<em>P8</em></h3><p>大量问题的最低求解时间成本都远远超出目前实际系统所能提供的计算能力，这类问题被称为难解问题。</p>
<h3 id="时间复杂度（time-complexity）P8"><a href="#时间复杂度（time-complexity）P8" class="headerlink" title="时间复杂度（time complexity）P8"></a>时间复杂度（time complexity）<em>P8</em></h3><p>执行时间的这一变化趋势可表示为输入规模的一个函数，称作该算法的时间复杂度。</p>
<h3 id="渐进分析（asymptotic-analysis）P9"><a href="#渐进分析（asymptotic-analysis）P9" class="headerlink" title="渐进分析（asymptotic analysis）P9"></a>渐进分析（asymptotic analysis）<em>P9</em></h3><p>在评价算法运行效率时，我们往往可以忽略其处理小规模问题时的能力差异，转而关注其在处理更大规模问题时的表现，这种从长远、更为注重时间复杂度的总体变化趋势和增长速度的策略和方法，即所谓的渐进分析法。</p>
<h3 id="大O记号（big-O-notation）P9"><a href="#大O记号（big-O-notation）P9" class="headerlink" title="大O记号（big-O notation）P9"></a>大O记号（big-O notation）<em>P9</em></h3><p>针对足够大的输入规模n，我们把算法执行时间计为T（n）。T（n）的渐进上界即为O（n）。具体地，若存在正的常数c和函数f（n），使得对于任何n&gt;&gt;2都有</p>
<blockquote>
<p>T（n）&lt;=  c·（f（n））</p>
</blockquote>
<p>则可认为在n足够大之后，f（n）给出了T（n）增长速度的一个渐进上界，此时记之为：</p>
<blockquote>
<p>T（n）=  O（n）</p>
</blockquote>
<p>由这一定义，可导出大O记号的以下性质：</p>
<blockquote>
<p>(1)对于任意常数c&gt;0,有O（f（n））=O（c·f（n））<br>(2)对于任意常数a&gt;b&gt;0，有O（n^a+n^b)=O(n^a)</p>
</blockquote>
<h3 id="图灵机（Turning-Machine）和随机存储机（Random-Access-Machine，RAM）P9"><a href="#图灵机（Turning-Machine）和随机存储机（Random-Access-Machine，RAM）P9" class="headerlink" title="图灵机（Turning Machine）和随机存储机（Random Access Machine，RAM）P9"></a>图灵机（Turning Machine）和随机存储机（Random Access Machine，RAM）<em>P9</em></h3><p>在这些计算模型中，指令语句均可分解为若干次基本操作，比如算数运算、比较、分支、子程序点用与往返等；而在大多素实际的计算环境中，每次这种类型的基本操作都可在常数时间内完成。如此，不妨将T（n）定义为算法所执行基本操作的总次数。</p>
<h3 id="最坏情况（worst-case）P10"><a href="#最坏情况（worst-case）P10" class="headerlink" title="最坏情况（worst case）P10"></a>最坏情况（worst case）<em>P10</em></h3><p>该算法的任何程序所需要的时间绝对不会超过这个情况。</p>
<h3 id="最好情况（best-case）P10"><a href="#最好情况（best-case）P10" class="headerlink" title="最好情况（best case）P10"></a>最好情况（best case）<em>P10</em></h3><h3 id="平均情况（average-case）P10"><a href="#平均情况（average-case）P10" class="headerlink" title="平均情况（average case）P10"></a>平均情况（average case）<em>P10</em></h3><p>按照某种约定的概率分布，将规模为n的所有输入对应的计算时间加权平均。</p>
<h3 id="大欧米茄记号"><a href="#大欧米茄记号" class="headerlink" title="大欧米茄记号"></a>大欧米茄记号</h3><h3 id="空间复杂度（space-complexity）P11"><a href="#空间复杂度（space-complexity）P11" class="headerlink" title="空间复杂度（space complexity）P11"></a>空间复杂度（space complexity）<em>P11</em></h3><p>算法所需存储空间的多少也是衡量其性能的一个重要方面。</p>
<h3 id="常数时间复杂度算法（constant-time-algorithm）P12"><a href="#常数时间复杂度算法（constant-time-algorithm）P12" class="headerlink" title="常数时间复杂度算法（constant-time algorithm）P12"></a>常数时间复杂度算法（constant-time algorithm）<em>P12</em></h3><p>运行时间可表示和度量为T（n） = O（1）的这类算法，统称为“常数时间复杂度算法”。</p>
<h3 id="对数时间复杂度（logarithmic-time-algorithm）P13"><a href="#对数时间复杂度（logarithmic-time-algorithm）P13" class="headerlink" title="对数时间复杂度（logarithmic-time algorithm）P13"></a>对数时间复杂度（logarithmic-time algorithm）<em>P13</em></h3><p>由大O记号定义，在用函数logr(n)界定渐进复杂度时，常底数r的具体值无所谓，故通常不予专门标出而笼统地记作logn ，可直接记作O（logn）。</p>
<h3 id="线性时间复杂度（liner-time-algorithm）P14"><a href="#线性时间复杂度（liner-time-algorithm）P14" class="headerlink" title="线性时间复杂度（liner-time algorithm）P14"></a>线性时间复杂度（liner-time algorithm）<em>P14</em></h3><p>凡运行时间可以表示和度量为T（n）=  O（n）形式的这一类算法。</p>
<h3 id="多项式时间复杂度（polynomial-time-algorithm）P14"><a href="#多项式时间复杂度（polynomial-time-algorithm）P14" class="headerlink" title="多项式时间复杂度（polynomial-time algorithm）P14"></a>多项式时间复杂度（polynomial-time algorithm）<em>P14</em></h3><p>若运行时间可以表示和度量为T（n）= O（f（n））的形式，而且f（x）为多项式。</p>
<h3 id="可有效求解-易解性（tractable）P14"><a href="#可有效求解-易解性（tractable）P14" class="headerlink" title="可有效求解/易解性（tractable）P14"></a>可有效求解/易解性（tractable）<em>P14</em></h3><p>在多项式时间复杂度范围内的算法，被称为有效求解的或易解的。</p>
<h3 id="指数时间复杂度算法（exponential-time-algorithm）P15"><a href="#指数时间复杂度算法（exponential-time-algorithm）P15" class="headerlink" title="指数时间复杂度算法（exponential-time algorithm）P15"></a>指数时间复杂度算法（exponential-time algorithm）<em>P15</em></h3><p>凡运行时间可以表示和度为T（n）= O（a^n）形式的算法（a&gt;1)</p>
<h3 id="难解（intractable）P15"><a href="#难解（intractable）P15" class="headerlink" title="难解（intractable）P15"></a>难解（intractable）<em>P15</em></h3><p>不在多项式复杂度算法的问题</p>
<h3 id="伪对数（pseudo-logarithm）和伪线性（pseudo-liner）的复杂度P16"><a href="#伪对数（pseudo-logarithm）和伪线性（pseudo-liner）的复杂度P16" class="headerlink" title="伪对数（pseudo-logarithm）和伪线性（pseudo-liner）的复杂度P16"></a>伪对数（pseudo-logarithm）和伪线性（pseudo-liner）的复杂度<em>P16</em></h3><p>对待计算问题的输入规模，应严格定义为“用以描述输入所需的空间规模”。有的算法以输入参数n本身的数值作为基准而得出的O（logn）和O（n）复杂度，应该用参数n二进制展开的宽度r作为输入规模更为合理，也就是用O（r）和O（2^r）。</p>
<h3 id="递归调用（recursive-call）P16"><a href="#递归调用（recursive-call）P16" class="headerlink" title="递归调用（recursive call）P16"></a>递归调用（recursive call）<em>P16</em></h3><p>递归则是函数和过程点用的一种特殊形式，即允许函数和过程进行自我调用。</p>
<h3 id="递归基（base-case-of-recursion）P17"><a href="#递归基（base-case-of-recursion）P17" class="headerlink" title="递归基（base case of recursion）P17"></a>递归基（base case of recursion）<em>P17</em></h3><p>首先判断平凡情况的，以免因无限递归而导致系统溢出。</p>
<h3 id="线性递归（linear-recursion）P17"><a href="#线性递归（linear-recursion）P17" class="headerlink" title="线性递归（linear recursion）P17"></a>线性递归（linear recursion）<em>P17</em></h3><p>每一层次上至多只有一个实例，而且它们构成一个线性的次序关系。</p>
<h3 id="减而治之（decrease-and-conquer）P17"><a href="#减而治之（decrease-and-conquer）P17" class="headerlink" title="减而治之（decrease-and-conquer）P17"></a>减而治之（decrease-and-conquer）<em>P17</em></h3><p>线性递归的模式，往往对应于所谓减而治之的算法策略：递归每深入一层，待求解问题的规模都缩减一个常数，直至最终蜕化为平凡的小（简单）问题。</p>
<h3 id="递归跟踪（recursion-trace）P17"><a href="#递归跟踪（recursion-trace）P17" class="headerlink" title="递归跟踪（recursion trace）P17"></a>递归跟踪（recursion trace）<em>P17</em></h3><p>作为一种直观且可视的方法，可用于分析递归算法的总体运行时间与空间，具体就是按以下原则，将递归算法的执行过程整理为图的形式：</p>
<blockquote>
<p>算法的每一递归实例都表示为一个方框，其中注明了该实例调用的参数<br>若实例M调用实例N，则在M与N对应的方框之间添加一条有向联线</p>
</blockquote>
<h3 id="递推方程（recurrence-equation）P19"><a href="#递推方程（recurrence-equation）P19" class="headerlink" title="递推方程（recurrence equation）P19"></a>递推方程（recurrence equation）<em>P19</em></h3><p>与跟踪分析相反，该方法无需绘出具体的调用过程，而是通过对递归模式的数学归纳，导出复杂度定界函数的递推方程（组）及其边界条件，从而将复杂度的分析，转化为递归方程（组）的求解。</p>
<h3 id="函数重载（overload）P20"><a href="#函数重载（overload）P20" class="headerlink" title="函数重载（overload）P20"></a>函数重载（overload）<em>P20</em></h3><p>函数重载机制定义了名称相同、参数表有别的函数。</p>
<h3 id="尾递归（tail-recursion）P22"><a href="#尾递归（tail-recursion）P22" class="headerlink" title="尾递归（tail recursion）P22"></a>尾递归（tail recursion）<em>P22</em></h3><p>在线性递归算法中，若递归调用在递归实例中恰好以最后一步操作的形式出现，则称作尾递归。</p>
<h3 id="分而治之（divide-and-conquer）P22"><a href="#分而治之（divide-and-conquer）P22" class="headerlink" title="分而治之（divide-and-conquer）P22"></a>分而治之（divide-and-conquer）<em>P22</em></h3><p>就是将问题分解为若干规模更小的子问题，再通过递归机制分别求解。这种分解持续进行，直到子问题规模缩减至平凡情况。</p>
<h3 id="多路递归（multi-way-recursion）P23"><a href="#多路递归（multi-way-recursion）P23" class="headerlink" title="多路递归（multi-way recursion）P23"></a>多路递归（multi-way recursion）<em>P23</em></h3><p>与减而治之的策略一样，这里也对原问题重新表述，以保证子问题与原问题在接口形式上的一致。既然每一递归实例都可能做多次递归，故称作“多路递归”。通常将问原问题一分为二，故称作“二分递归”（binary recursion）。要强调的是，无论是分解为两个还是更大常数个子问题，对算法总体的渐进复杂并无实质影响。</p>
<h3 id="制表（tabulation）-记忆（memoization）P25"><a href="#制表（tabulation）-记忆（memoization）P25" class="headerlink" title="制表（tabulation）/记忆（memoization）P25"></a>制表（tabulation）/记忆（memoization）<em>P25</em></h3><p>可以从原问题出发自顶而下，每当遇到一个子问题，都首先检查它是否已经计算过，以其通过直接调阅记录获得解答，从而避免重新计算。</p>
<h3 id="动态规划（dynamic-programming）P25"><a href="#动态规划（dynamic-programming）P25" class="headerlink" title="动态规划（dynamic programming）P25"></a>动态规划（dynamic programming）<em>P25</em></h3><p>可以递归基出发，自底而上递推地得出各子问题的解，直至最终原问题的解。</p>
<h3 id="抽象数据类型（abstract-data-type，ADT）P26"><a href="#抽象数据类型（abstract-data-type，ADT）P26" class="headerlink" title="抽象数据类型（abstract data type，ADT）P26"></a>抽象数据类型（abstract data type，ADT）<em>P26</em></h3><p>数据集合及其对应的操作可超脱于具体的程序设计语言、具体的实现方式，即构成所谓的抽象数据类型。</p>
<h3 id="接口（interface）、实现（implementation）P26"><a href="#接口（interface）、实现（implementation）P26" class="headerlink" title="接口（interface）、实现（implementation）P26"></a>接口（interface）、实现（implementation）<em>P26</em></h3><p>具体将从数据结构的对外接口出发，以c++语言为例，逐层讲解其内部具体实现的原理、方法与技巧，并就不同实现方式的效率及实用范围进行分析与比较。</p>
]]></content>
      <categories>
        <category>-学习</category>
      </categories>
      <tags>
        <tag>-数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>hoxe系列（一）搭建博客网站</title>
    <url>/2019/12/02/page/</url>
    <content><![CDATA[<blockquote>
<p>“  真正被爱的人在爱人眼里是绽放的丁香，航船渔火，学校铃声，山水风景，难以忘怀的谈话，朋友，孩子的周日，消逝的声音，最心爱的衣服，秋天和所有的季节。 ”<br>/ 杜鲁门·卡波特《别的声音，别的房间》</p>
</blockquote>
<a id="more"></a>
<p>早就想搭建一个个人博客了，因为一直以来都挺喜欢写写文字记录一下感想和生活的。但是本菜鸡断断续续地学了半年前端、H5、CSS、Js甚至还涉及到了React还有flutter，但是都因为觉得自己搭站工程巨大，遥遥无期，都没有坚持，半途而废了。无意中看别人的博客，发现用hexo和git一起搭建个人博客还是挺简单的，自己试了下，大概用了两个小时就搭建完成了。美滋滋。写篇文章得瑟一下。</p>
<h4 id="搭建环境："><a href="#搭建环境：" class="headerlink" title="搭建环境："></a>搭建环境：</h4><p>Caralina 10.15.1</p>
<h4 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h4><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>在官网上下载了pkg，双击安装。<br>git电脑上默认就安装了。</p>
<p>安装好Node.js以后，使用npm完成对hexo的安装。打开终端，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span></pre></td></tr></table></figure>
<p>视个人网速等待一会之后，hexo就安装完成了。</p>
<h3 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h3><p>先在自己喜欢的任何地方建一个文件夹，终端输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init _folder_</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ cd folder</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ npm install</span></pre></td></tr></table></figure>
<p>这时我们的博客雏形其实已经搭建好了，文件内容已经由hexo帮我们生成了建站所有需要的文件。<br>首先我们先关注根目录下的_config.yml文件，它包括了网站需要的配置信息，可以配置绝大部分的参数。<br>首先我们一定要改的一般是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: your website title</span></pre></td></tr><tr><td class="code"><pre><span class="line">subtitle: xxxx</span></pre></td></tr><tr><td class="code"><pre><span class="line">author: your name</span></pre></td></tr><tr><td class="code"><pre><span class="line">url: 你挂靠的网页的网址（这个我们会在下文提到）</span></pre></td></tr></table></figure>
<p>别的可以暂时用默认值。<br>其中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: landscape#是我们马上要继续讲的主题</span></pre></td></tr></table></figure>
<p><strong>重要的是，冒号后面一定要有英文半角的空格</strong><br>剩下目前我们就需要关注两个文件夹：<br><strong>source:</strong>存放我们写的文章和草稿<br><strong>theme:</strong>主题文件夹。hexo就是根据它来生成我们的网页页面，网站最终会是什么样子的，就依靠这个来决定。这个<a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">知乎</a>链接里有主题的评星、链接和示例图，大家可以用来参考选择。<br>现在先不管这两个文件夹，再次回到termial，输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d -g</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ hexo server</span></pre></td></tr></table></figure>
<p>其中d指deploy也就是部署，-g指generate，表示如果部署时还没生成静态页面就先执行generate，这实际上是两个操作，我们这里一步来完成。等一小段时间，网页就部署好了，这时候输入第二行代码，terminal上会显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO  Hexo is running at http:&#x2F;&#x2F;0.0.0.0:4000&#x2F;. Press Ctrl+C to stop.</span></pre></td></tr></table></figure>
<p>我们在浏览器中输入<a href="http://0.0.0.0:4000就能看到刚才的部署的页面了，就是我们博客的样子～" target="_blank" rel="noopener">http://0.0.0.0:4000就能看到刚才的部署的页面了，就是我们博客的样子～</a><br>现在只能本地访问，如果我们希望其他人也能看到，就需要将网页部署到某个服务上去。我选择了github，其他方式操作应该也是类似的。</p>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>首先要注册一个github的账号，然后按照<a href="https://pages.github.com/" target="_blank" rel="noopener">Github Page</a>这上面的步骤，我们就能获得一个类似于https://<em>usernam</em>.github.io的域名地址。同时我们在github上也有一个对应的repository，用来存放我们页面的内容。<br>这时候，打开前面提到的根目录下的_config.yml，在url后填入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url: https:&#x2F;&#x2F;username.github.io#对应你自己的地址</span></pre></td></tr></table></figure>
<p>在文件底部的deploy填入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span></pre></td></tr><tr><td class="code"><pre><span class="line">type: git</span></pre></td></tr><tr><td class="code"><pre><span class="line">repo: &lt;repositoty url&gt; #前面获得域名时创建的repository地址,注意和前面的那个url是不一样的，这里是repository的地址，在github上可以看到</span></pre></td></tr><tr><td class="code"><pre><span class="line">branch: [branch] #要发布内容的分支，一般是master</span></pre></td></tr><tr><td class="code"><pre><span class="line">message: [message] ##自定义提交信息，留空就可以。</span></pre></td></tr></table></figure>
<p>这时我们再打开terminal，输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d -g</span></pre></td></tr></table></figure>
<p>我在这里出现了报错，提示无法链接git或者找不到git，解决办法是安装<code>hexo-deployer-git</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span></pre></td></tr></table></figure>
<p>这个地方提示要输入GitHub的账号和密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Username for GitHub:</span></pre></td></tr><tr><td class="code"><pre><span class="line">Password for GitHub:</span></pre></td></tr></table></figure>
<p>网页就被部署到<a href="https://username.github.io上了，稍等几分钟，在浏览器的地址栏输入，就能访问博客。" target="_blank" rel="noopener">https://username.github.io上了，稍等几分钟，在浏览器的地址栏输入，就能访问博客。</a><br>至此，博客建站完毕。</p>
<h3 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h3><p>在前文提到过的source文件夹下，新建一个*.md文件，想写的内容填进去，重新生成、部署，稍等会就能看到我们更新的博客了。</p>
<h3 id="其他插件"><a href="#其他插件" class="headerlink" title="其他插件"></a>其他插件</h3><p>其他还有一些博客管理内容，比如google analytical统计，dispute评论栏，都可以很简单的添加到页面中。在后面对blog的完善中会继续提到。</p>
]]></content>
      <categories>
        <category>-学习</category>
      </categories>
      <tags>
        <tag>-建站 - hoxe</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/01/hello-world/</url>
    <content><![CDATA[<p>欢迎来到菜鸡Kaia的部落格。<br>分享生活和学习的日常。<br>望常更新：）<br>接受催更。</p>
]]></content>
      <categories>
        <category>-生活</category>
      </categories>
  </entry>
</search>
